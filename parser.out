Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    ANDEQUAL
    ARROW
    AUTO
    BREAK
    CASE
    COLON
    CONST
    CONTINUE
    DECREMENT
    DEFAULT
    DIVEQUAL
    DO
    DOUBLE
    DQUOT
    ELLIPSIS
    ELSE
    ENUM
    EQ
    EXTERN
    FLOAT
    FOR
    GE
    GOTO
    IF
    INCREMENT
    LAND
    LANGLE
    LBRACKET
    LE
    LNOT
    LONG
    LOR
    LSHIFT
    LSHIFTEQUAL
    MINUSEQUAL
    MODEQUAL
    NE
    NOT
    OR
    OREQUAL
    PERIOD
    PLUSEQUAL
    RANGLE
    RBRACKET
    REGISTER
    RSHIFT
    RSHIFTEQUAL
    SHORT
    SIGNED
    SIZEOF
    SQUOT
    STATIC
    STRUCT
    SWITCH
    TIMESEQUAL
    TYPEDEF
    UNION
    UNSIGNED
    VOID
    VOLATILE
    WHILE
    XOR
    XOREQUAL

Grammar

Rule 0     S' -> funcDecl
Rule 1     empty -> <empty>
Rule 2     statement_list -> empty
Rule 3     statement_list -> statement SEMI statement_list
Rule 4     statement -> return_stmt
Rule 5     statement -> var_decl
Rule 6     statement -> var_assign
Rule 7     statement -> empty
Rule 8     expr -> var bin_op var
Rule 9     var -> ID
Rule 10    var -> NUMCONST
Rule 11    bin_op -> PLUS
Rule 12    bin_op -> MINUS
Rule 13    bin_op -> TIMES
Rule 14    bin_op -> DIVIDE
Rule 15    bin_op -> MODULO
Rule 16    return_stmt -> RETURN var
Rule 17    return_stmt -> RETURN expr
Rule 18    return_stmt -> RETURN var_assign
Rule 19    var_decl -> type_spec ID
Rule 20    var_decl -> type_spec var_assign
Rule 21    var_assign -> ID EQUALS var
Rule 22    var_assign -> ID EQUALS expr
Rule 23    var_assign -> ID EQUALS STRING
Rule 24    var_assign -> LPAREN var_assign RPAREN
Rule 25    type_spec_list -> type_spec_list COMMA type_spec ID
Rule 26    type_spec_list -> type_spec ID
Rule 27    type_spec -> INT
Rule 28    type_spec -> CHAR
Rule 29    scope -> LBRACE statement_list RBRACE
Rule 30    funcDecl -> type_spec ID LPAREN args RPAREN scope
Rule 31    args -> type_spec_list
Rule 32    args -> empty

Terminals, with rules where they appear

AND                  : 
ANDEQUAL             : 
ARROW                : 
AUTO                 : 
BREAK                : 
CASE                 : 
CHAR                 : 28
COLON                : 
COMMA                : 25
CONST                : 
CONTINUE             : 
DECREMENT            : 
DEFAULT              : 
DIVEQUAL             : 
DIVIDE               : 14
DO                   : 
DOUBLE               : 
DQUOT                : 
ELLIPSIS             : 
ELSE                 : 
ENUM                 : 
EQ                   : 
EQUALS               : 21 22 23
EXTERN               : 
FLOAT                : 
FOR                  : 
GE                   : 
GOTO                 : 
ID                   : 9 19 21 22 23 25 26 30
IF                   : 
INCREMENT            : 
INT                  : 27
LAND                 : 
LANGLE               : 
LBRACE               : 29
LBRACKET             : 
LE                   : 
LNOT                 : 
LONG                 : 
LOR                  : 
LPAREN               : 24 30
LSHIFT               : 
LSHIFTEQUAL          : 
MINUS                : 12
MINUSEQUAL           : 
MODEQUAL             : 
MODULO               : 15
NE                   : 
NOT                  : 
NUMCONST             : 10
OR                   : 
OREQUAL              : 
PERIOD               : 
PLUS                 : 11
PLUSEQUAL            : 
RANGLE               : 
RBRACE               : 29
RBRACKET             : 
REGISTER             : 
RETURN               : 16 17 18
RPAREN               : 24 30
RSHIFT               : 
RSHIFTEQUAL          : 
SEMI                 : 3
SHORT                : 
SIGNED               : 
SIZEOF               : 
SQUOT                : 
STATIC               : 
STRING               : 23
STRUCT               : 
SWITCH               : 
TIMES                : 13
TIMESEQUAL           : 
TYPEDEF              : 
UNION                : 
UNSIGNED             : 
VOID                 : 
VOLATILE             : 
WHILE                : 
XOR                  : 
XOREQUAL             : 
error                : 

Nonterminals, with rules where they appear

args                 : 30
bin_op               : 8
empty                : 2 7 32
expr                 : 17 22
funcDecl             : 0
return_stmt          : 4
scope                : 30
statement            : 3
statement_list       : 3 29
type_spec            : 19 20 25 26 30
type_spec_list       : 25 31
var                  : 8 8 16 21
var_assign           : 6 18 20 24
var_decl             : 5

Parsing method: LALR

state 0

    (0) S' -> . funcDecl
    (30) funcDecl -> . type_spec ID LPAREN args RPAREN scope
    (27) type_spec -> . INT
    (28) type_spec -> . CHAR

    INT             shift and go to state 3
    CHAR            shift and go to state 4

    funcDecl                       shift and go to state 1
    type_spec                      shift and go to state 2

state 1

    (0) S' -> funcDecl .



state 2

    (30) funcDecl -> type_spec . ID LPAREN args RPAREN scope

    ID              shift and go to state 5


state 3

    (27) type_spec -> INT .

    ID              reduce using rule 27 (type_spec -> INT .)
    LPAREN          reduce using rule 27 (type_spec -> INT .)


state 4

    (28) type_spec -> CHAR .

    ID              reduce using rule 28 (type_spec -> CHAR .)
    LPAREN          reduce using rule 28 (type_spec -> CHAR .)


state 5

    (30) funcDecl -> type_spec ID . LPAREN args RPAREN scope

    LPAREN          shift and go to state 6


state 6

    (30) funcDecl -> type_spec ID LPAREN . args RPAREN scope
    (31) args -> . type_spec_list
    (32) args -> . empty
    (25) type_spec_list -> . type_spec_list COMMA type_spec ID
    (26) type_spec_list -> . type_spec ID
    (1) empty -> .
    (27) type_spec -> . INT
    (28) type_spec -> . CHAR

    RPAREN          reduce using rule 1 (empty -> .)
    INT             shift and go to state 3
    CHAR            shift and go to state 4

    type_spec                      shift and go to state 7
    args                           shift and go to state 8
    type_spec_list                 shift and go to state 9
    empty                          shift and go to state 10

state 7

    (26) type_spec_list -> type_spec . ID

    ID              shift and go to state 11


state 8

    (30) funcDecl -> type_spec ID LPAREN args . RPAREN scope

    RPAREN          shift and go to state 12


state 9

    (31) args -> type_spec_list .
    (25) type_spec_list -> type_spec_list . COMMA type_spec ID

    RPAREN          reduce using rule 31 (args -> type_spec_list .)
    COMMA           shift and go to state 13


state 10

    (32) args -> empty .

    RPAREN          reduce using rule 32 (args -> empty .)


state 11

    (26) type_spec_list -> type_spec ID .

    COMMA           reduce using rule 26 (type_spec_list -> type_spec ID .)
    RPAREN          reduce using rule 26 (type_spec_list -> type_spec ID .)


state 12

    (30) funcDecl -> type_spec ID LPAREN args RPAREN . scope
    (29) scope -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 15

    scope                          shift and go to state 14

state 13

    (25) type_spec_list -> type_spec_list COMMA . type_spec ID
    (27) type_spec -> . INT
    (28) type_spec -> . CHAR

    INT             shift and go to state 3
    CHAR            shift and go to state 4

    type_spec                      shift and go to state 16

state 14

    (30) funcDecl -> type_spec ID LPAREN args RPAREN scope .

    $end            reduce using rule 30 (funcDecl -> type_spec ID LPAREN args RPAREN scope .)


state 15

    (29) scope -> LBRACE . statement_list RBRACE
    (2) statement_list -> . empty
    (3) statement_list -> . statement SEMI statement_list
    (1) empty -> .
    (4) statement -> . return_stmt
    (5) statement -> . var_decl
    (6) statement -> . var_assign
    (7) statement -> . empty
    (16) return_stmt -> . RETURN var
    (17) return_stmt -> . RETURN expr
    (18) return_stmt -> . RETURN var_assign
    (19) var_decl -> . type_spec ID
    (20) var_decl -> . type_spec var_assign
    (21) var_assign -> . ID EQUALS var
    (22) var_assign -> . ID EQUALS expr
    (23) var_assign -> . ID EQUALS STRING
    (24) var_assign -> . LPAREN var_assign RPAREN
    (27) type_spec -> . INT
    (28) type_spec -> . CHAR

    RBRACE          reduce using rule 1 (empty -> .)
    SEMI            reduce using rule 1 (empty -> .)
    RETURN          shift and go to state 23
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    INT             shift and go to state 3
    CHAR            shift and go to state 4

    statement_list                 shift and go to state 17
    empty                          shift and go to state 18
    statement                      shift and go to state 19
    return_stmt                    shift and go to state 20
    var_decl                       shift and go to state 21
    var_assign                     shift and go to state 22
    type_spec                      shift and go to state 24

state 16

    (25) type_spec_list -> type_spec_list COMMA type_spec . ID

    ID              shift and go to state 27


state 17

    (29) scope -> LBRACE statement_list . RBRACE

    RBRACE          shift and go to state 28


state 18

    (2) statement_list -> empty .
    (7) statement -> empty .

    RBRACE          reduce using rule 2 (statement_list -> empty .)
    SEMI            reduce using rule 7 (statement -> empty .)


state 19

    (3) statement_list -> statement . SEMI statement_list

    SEMI            shift and go to state 29


state 20

    (4) statement -> return_stmt .

    SEMI            reduce using rule 4 (statement -> return_stmt .)


state 21

    (5) statement -> var_decl .

    SEMI            reduce using rule 5 (statement -> var_decl .)


state 22

    (6) statement -> var_assign .

    SEMI            reduce using rule 6 (statement -> var_assign .)


state 23

    (16) return_stmt -> RETURN . var
    (17) return_stmt -> RETURN . expr
    (18) return_stmt -> RETURN . var_assign
    (9) var -> . ID
    (10) var -> . NUMCONST
    (8) expr -> . var bin_op var
    (21) var_assign -> . ID EQUALS var
    (22) var_assign -> . ID EQUALS expr
    (23) var_assign -> . ID EQUALS STRING
    (24) var_assign -> . LPAREN var_assign RPAREN

    ID              shift and go to state 33
    NUMCONST        shift and go to state 34
    LPAREN          shift and go to state 26

    var                            shift and go to state 30
    expr                           shift and go to state 31
    var_assign                     shift and go to state 32

state 24

    (19) var_decl -> type_spec . ID
    (20) var_decl -> type_spec . var_assign
    (21) var_assign -> . ID EQUALS var
    (22) var_assign -> . ID EQUALS expr
    (23) var_assign -> . ID EQUALS STRING
    (24) var_assign -> . LPAREN var_assign RPAREN

    ID              shift and go to state 35
    LPAREN          shift and go to state 26

    var_assign                     shift and go to state 36

state 25

    (21) var_assign -> ID . EQUALS var
    (22) var_assign -> ID . EQUALS expr
    (23) var_assign -> ID . EQUALS STRING

    EQUALS          shift and go to state 37


state 26

    (24) var_assign -> LPAREN . var_assign RPAREN
    (21) var_assign -> . ID EQUALS var
    (22) var_assign -> . ID EQUALS expr
    (23) var_assign -> . ID EQUALS STRING
    (24) var_assign -> . LPAREN var_assign RPAREN

    ID              shift and go to state 25
    LPAREN          shift and go to state 26

    var_assign                     shift and go to state 38

state 27

    (25) type_spec_list -> type_spec_list COMMA type_spec ID .

    COMMA           reduce using rule 25 (type_spec_list -> type_spec_list COMMA type_spec ID .)
    RPAREN          reduce using rule 25 (type_spec_list -> type_spec_list COMMA type_spec ID .)


state 28

    (29) scope -> LBRACE statement_list RBRACE .

    $end            reduce using rule 29 (scope -> LBRACE statement_list RBRACE .)


state 29

    (3) statement_list -> statement SEMI . statement_list
    (2) statement_list -> . empty
    (3) statement_list -> . statement SEMI statement_list
    (1) empty -> .
    (4) statement -> . return_stmt
    (5) statement -> . var_decl
    (6) statement -> . var_assign
    (7) statement -> . empty
    (16) return_stmt -> . RETURN var
    (17) return_stmt -> . RETURN expr
    (18) return_stmt -> . RETURN var_assign
    (19) var_decl -> . type_spec ID
    (20) var_decl -> . type_spec var_assign
    (21) var_assign -> . ID EQUALS var
    (22) var_assign -> . ID EQUALS expr
    (23) var_assign -> . ID EQUALS STRING
    (24) var_assign -> . LPAREN var_assign RPAREN
    (27) type_spec -> . INT
    (28) type_spec -> . CHAR

    RBRACE          reduce using rule 1 (empty -> .)
    SEMI            reduce using rule 1 (empty -> .)
    RETURN          shift and go to state 23
    ID              shift and go to state 25
    LPAREN          shift and go to state 26
    INT             shift and go to state 3
    CHAR            shift and go to state 4

    statement                      shift and go to state 19
    statement_list                 shift and go to state 39
    empty                          shift and go to state 18
    return_stmt                    shift and go to state 20
    var_decl                       shift and go to state 21
    var_assign                     shift and go to state 22
    type_spec                      shift and go to state 24

state 30

    (16) return_stmt -> RETURN var .
    (8) expr -> var . bin_op var
    (11) bin_op -> . PLUS
    (12) bin_op -> . MINUS
    (13) bin_op -> . TIMES
    (14) bin_op -> . DIVIDE
    (15) bin_op -> . MODULO

    SEMI            reduce using rule 16 (return_stmt -> RETURN var .)
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 44
    MODULO          shift and go to state 45

    bin_op                         shift and go to state 40

state 31

    (17) return_stmt -> RETURN expr .

    SEMI            reduce using rule 17 (return_stmt -> RETURN expr .)


state 32

    (18) return_stmt -> RETURN var_assign .

    SEMI            reduce using rule 18 (return_stmt -> RETURN var_assign .)


state 33

    (9) var -> ID .
    (21) var_assign -> ID . EQUALS var
    (22) var_assign -> ID . EQUALS expr
    (23) var_assign -> ID . EQUALS STRING

    PLUS            reduce using rule 9 (var -> ID .)
    MINUS           reduce using rule 9 (var -> ID .)
    TIMES           reduce using rule 9 (var -> ID .)
    DIVIDE          reduce using rule 9 (var -> ID .)
    MODULO          reduce using rule 9 (var -> ID .)
    SEMI            reduce using rule 9 (var -> ID .)
    EQUALS          shift and go to state 37


state 34

    (10) var -> NUMCONST .

    PLUS            reduce using rule 10 (var -> NUMCONST .)
    MINUS           reduce using rule 10 (var -> NUMCONST .)
    TIMES           reduce using rule 10 (var -> NUMCONST .)
    DIVIDE          reduce using rule 10 (var -> NUMCONST .)
    MODULO          reduce using rule 10 (var -> NUMCONST .)
    SEMI            reduce using rule 10 (var -> NUMCONST .)
    RPAREN          reduce using rule 10 (var -> NUMCONST .)


state 35

    (19) var_decl -> type_spec ID .
    (21) var_assign -> ID . EQUALS var
    (22) var_assign -> ID . EQUALS expr
    (23) var_assign -> ID . EQUALS STRING

    SEMI            reduce using rule 19 (var_decl -> type_spec ID .)
    EQUALS          shift and go to state 37


state 36

    (20) var_decl -> type_spec var_assign .

    SEMI            reduce using rule 20 (var_decl -> type_spec var_assign .)


state 37

    (21) var_assign -> ID EQUALS . var
    (22) var_assign -> ID EQUALS . expr
    (23) var_assign -> ID EQUALS . STRING
    (9) var -> . ID
    (10) var -> . NUMCONST
    (8) expr -> . var bin_op var

    STRING          shift and go to state 49
    ID              shift and go to state 46
    NUMCONST        shift and go to state 34

    var                            shift and go to state 47
    expr                           shift and go to state 48

state 38

    (24) var_assign -> LPAREN var_assign . RPAREN

    RPAREN          shift and go to state 50


state 39

    (3) statement_list -> statement SEMI statement_list .

    RBRACE          reduce using rule 3 (statement_list -> statement SEMI statement_list .)


state 40

    (8) expr -> var bin_op . var
    (9) var -> . ID
    (10) var -> . NUMCONST

    ID              shift and go to state 46
    NUMCONST        shift and go to state 34

    var                            shift and go to state 51

state 41

    (11) bin_op -> PLUS .

    ID              reduce using rule 11 (bin_op -> PLUS .)
    NUMCONST        reduce using rule 11 (bin_op -> PLUS .)


state 42

    (12) bin_op -> MINUS .

    ID              reduce using rule 12 (bin_op -> MINUS .)
    NUMCONST        reduce using rule 12 (bin_op -> MINUS .)


state 43

    (13) bin_op -> TIMES .

    ID              reduce using rule 13 (bin_op -> TIMES .)
    NUMCONST        reduce using rule 13 (bin_op -> TIMES .)


state 44

    (14) bin_op -> DIVIDE .

    ID              reduce using rule 14 (bin_op -> DIVIDE .)
    NUMCONST        reduce using rule 14 (bin_op -> DIVIDE .)


state 45

    (15) bin_op -> MODULO .

    ID              reduce using rule 15 (bin_op -> MODULO .)
    NUMCONST        reduce using rule 15 (bin_op -> MODULO .)


state 46

    (9) var -> ID .

    PLUS            reduce using rule 9 (var -> ID .)
    MINUS           reduce using rule 9 (var -> ID .)
    TIMES           reduce using rule 9 (var -> ID .)
    DIVIDE          reduce using rule 9 (var -> ID .)
    MODULO          reduce using rule 9 (var -> ID .)
    SEMI            reduce using rule 9 (var -> ID .)
    RPAREN          reduce using rule 9 (var -> ID .)


state 47

    (21) var_assign -> ID EQUALS var .
    (8) expr -> var . bin_op var
    (11) bin_op -> . PLUS
    (12) bin_op -> . MINUS
    (13) bin_op -> . TIMES
    (14) bin_op -> . DIVIDE
    (15) bin_op -> . MODULO

    SEMI            reduce using rule 21 (var_assign -> ID EQUALS var .)
    RPAREN          reduce using rule 21 (var_assign -> ID EQUALS var .)
    PLUS            shift and go to state 41
    MINUS           shift and go to state 42
    TIMES           shift and go to state 43
    DIVIDE          shift and go to state 44
    MODULO          shift and go to state 45

    bin_op                         shift and go to state 40

state 48

    (22) var_assign -> ID EQUALS expr .

    SEMI            reduce using rule 22 (var_assign -> ID EQUALS expr .)
    RPAREN          reduce using rule 22 (var_assign -> ID EQUALS expr .)


state 49

    (23) var_assign -> ID EQUALS STRING .

    SEMI            reduce using rule 23 (var_assign -> ID EQUALS STRING .)
    RPAREN          reduce using rule 23 (var_assign -> ID EQUALS STRING .)


state 50

    (24) var_assign -> LPAREN var_assign RPAREN .

    SEMI            reduce using rule 24 (var_assign -> LPAREN var_assign RPAREN .)
    RPAREN          reduce using rule 24 (var_assign -> LPAREN var_assign RPAREN .)


state 51

    (8) expr -> var bin_op var .

    SEMI            reduce using rule 8 (expr -> var bin_op var .)
    RPAREN          reduce using rule 8 (expr -> var bin_op var .)

