Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    ARROW
    AUTO
    CASE
    CHARACTER
    COLON
    CONST
    CONTINUE
    DEFAULT
    DO
    DOUBLE
    DQUOT
    ELLIPSIS
    ENUM
    EXTERN
    FLOAT
    FOR
    LAND
    LANGLE
    LBRACKET
    LNOT
    LONG
    LOR
    LSHIFT
    NOT
    OR
    PERIOD
    RANGLE
    RBRACKET
    REGISTER
    RSHIFT
    SHORT
    SIGNED
    SIZEOF
    SQUOT
    STATIC
    STRUCT
    SWITCH
    TYPEDEF
    UNION
    UNSIGNED
    VOID
    VOLATILE
    XOR

Grammar

Rule 0     S' -> funcDecl
Rule 1     empty -> <empty>
Rule 2     statement_list -> empty
Rule 3     statement_list -> statement SEMI statement_list
Rule 4     statement_list -> whileLoop statement_list
Rule 5     statement_list -> if_stmt statement_list
Rule 6     statement -> return_stmt
Rule 7     statement -> var_decl
Rule 8     statement -> var_assign
Rule 9     statement -> goto_stmt
Rule 10    statement -> break_stmt
Rule 11    statement -> empty
Rule 12    expr -> expr PLUS multiplicative_expr
Rule 13    expr -> expr MINUS multiplicative_expr
Rule 14    expr -> multiplicative_expr
Rule 15    multiplicative_expr -> multiplicative_expr TIMES unary_expr
Rule 16    multiplicative_expr -> multiplicative_expr DIVIDE unary_expr
Rule 17    multiplicative_expr -> multiplicative_expr MODULO unary_expr
Rule 18    multiplicative_expr -> unary_expr
Rule 19    unary_expr -> INCREMENT operand
Rule 20    unary_expr -> DECREMENT operand
Rule 21    unary_expr -> operand INCREMENT
Rule 22    unary_expr -> operand DECREMENT
Rule 23    operand -> ID
Rule 24    operand -> NUMCONST
Rule 25    return_stmt -> RETURN operand
Rule 26    return_stmt -> RETURN expr
Rule 27    return_stmt -> RETURN var_assign
Rule 28    var_decl -> type_spec ID
Rule 29    var_decl -> type_spec var_assign
Rule 30    var_assign -> ID EQUALS operand
Rule 31    var_assign -> ID EQUALS expr
Rule 32    var_assign -> ID EQUALS STRING
Rule 33    var_assign -> LPAREN var_assign RPAREN
Rule 34    var_assign -> ID TIMESEQUAL operand
Rule 35    var_assign -> ID DIVEQUAL operand
Rule 36    var_assign -> ID MODEQUAL operand
Rule 37    var_assign -> ID PLUSEQUAL operand
Rule 38    var_assign -> ID MINUSEQUAL operand
Rule 39    var_assign -> ID LSHIFTEQUAL operand
Rule 40    var_assign -> ID RSHIFTEQUAL operand
Rule 41    var_assign -> ID ANDEQUAL operand
Rule 42    var_assign -> ID OREQUAL operand
Rule 43    var_assign -> ID XOREQUAL operand
Rule 44    type_spec_list -> type_spec_list COMMA type_spec ID
Rule 45    type_spec_list -> type_spec ID
Rule 46    type_spec -> INT
Rule 47    type_spec -> CHAR
Rule 48    scope -> LBRACE statement_list RBRACE
Rule 49    funcDecl -> type_spec ID LPAREN args RPAREN scope
Rule 50    args -> type_spec_list
Rule 51    args -> empty
Rule 52    whileLoop -> WHILE LPAREN conditionals RPAREN scope
Rule 53    conditionals -> operand compOps operand
Rule 54    compOps -> LE
Rule 55    compOps -> GE
Rule 56    compOps -> EQ
Rule 57    compOps -> NE
Rule 58    break_stmt -> BREAK
Rule 59    goto_stmt -> GOTO ID
Rule 60    if_stmt -> IF LPAREN conditionals RPAREN scope
Rule 61    if_stmt -> IF LPAREN conditionals RPAREN scope elsiflist
Rule 62    elsiflist -> ELSE IF LPAREN conditionals RPAREN scope elsiflist
Rule 63    elsiflist -> ELSE IF LPAREN conditionals RPAREN scope empty
Rule 64    elsiflist -> ELSE scope

Terminals, with rules where they appear

AND                  : 
ANDEQUAL             : 41
ARROW                : 
AUTO                 : 
BREAK                : 58
CASE                 : 
CHAR                 : 47
CHARACTER            : 
COLON                : 
COMMA                : 44
CONST                : 
CONTINUE             : 
DECREMENT            : 20 22
DEFAULT              : 
DIVEQUAL             : 35
DIVIDE               : 16
DO                   : 
DOUBLE               : 
DQUOT                : 
ELLIPSIS             : 
ELSE                 : 62 63 64
ENUM                 : 
EQ                   : 56
EQUALS               : 30 31 32
EXTERN               : 
FLOAT                : 
FOR                  : 
GE                   : 55
GOTO                 : 59
ID                   : 23 28 30 31 32 34 35 36 37 38 39 40 41 42 43 44 45 49 59
IF                   : 60 61 62 63
INCREMENT            : 19 21
INT                  : 46
LAND                 : 
LANGLE               : 
LBRACE               : 48
LBRACKET             : 
LE                   : 54
LNOT                 : 
LONG                 : 
LOR                  : 
LPAREN               : 33 49 52 60 61 62 63
LSHIFT               : 
LSHIFTEQUAL          : 39
MINUS                : 13
MINUSEQUAL           : 38
MODEQUAL             : 36
MODULO               : 17
NE                   : 57
NOT                  : 
NUMCONST             : 24
OR                   : 
OREQUAL              : 42
PERIOD               : 
PLUS                 : 12
PLUSEQUAL            : 37
RANGLE               : 
RBRACE               : 48
RBRACKET             : 
REGISTER             : 
RETURN               : 25 26 27
RPAREN               : 33 49 52 60 61 62 63
RSHIFT               : 
RSHIFTEQUAL          : 40
SEMI                 : 3
SHORT                : 
SIGNED               : 
SIZEOF               : 
SQUOT                : 
STATIC               : 
STRING               : 32
STRUCT               : 
SWITCH               : 
TIMES                : 15
TIMESEQUAL           : 34
TYPEDEF              : 
UNION                : 
UNSIGNED             : 
VOID                 : 
VOLATILE             : 
WHILE                : 52
XOR                  : 
XOREQUAL             : 43
error                : 

Nonterminals, with rules where they appear

args                 : 49
break_stmt           : 10
compOps              : 53
conditionals         : 52 60 61 62 63
elsiflist            : 61 62
empty                : 2 11 51 63
expr                 : 12 13 26 31
funcDecl             : 0
goto_stmt            : 9
if_stmt              : 5
multiplicative_expr  : 12 13 14 15 16 17
operand              : 19 20 21 22 25 30 34 35 36 37 38 39 40 41 42 43 53 53
return_stmt          : 6
scope                : 49 52 60 61 62 63 64
statement            : 3
statement_list       : 3 4 5 48
type_spec            : 28 29 44 45 49
type_spec_list       : 44 50
unary_expr           : 15 16 17 18
var_assign           : 8 27 29 33
var_decl             : 7
whileLoop            : 4

Parsing method: LALR

state 0

    (0) S' -> . funcDecl
    (49) funcDecl -> . type_spec ID LPAREN args RPAREN scope
    (46) type_spec -> . INT
    (47) type_spec -> . CHAR

    INT             shift and go to state 3
    CHAR            shift and go to state 4

    funcDecl                       shift and go to state 1
    type_spec                      shift and go to state 2

state 1

    (0) S' -> funcDecl .



state 2

    (49) funcDecl -> type_spec . ID LPAREN args RPAREN scope

    ID              shift and go to state 5


state 3

    (46) type_spec -> INT .

    ID              reduce using rule 46 (type_spec -> INT .)
    LPAREN          reduce using rule 46 (type_spec -> INT .)


state 4

    (47) type_spec -> CHAR .

    ID              reduce using rule 47 (type_spec -> CHAR .)
    LPAREN          reduce using rule 47 (type_spec -> CHAR .)


state 5

    (49) funcDecl -> type_spec ID . LPAREN args RPAREN scope

    LPAREN          shift and go to state 6


state 6

    (49) funcDecl -> type_spec ID LPAREN . args RPAREN scope
    (50) args -> . type_spec_list
    (51) args -> . empty
    (44) type_spec_list -> . type_spec_list COMMA type_spec ID
    (45) type_spec_list -> . type_spec ID
    (1) empty -> .
    (46) type_spec -> . INT
    (47) type_spec -> . CHAR

    RPAREN          reduce using rule 1 (empty -> .)
    INT             shift and go to state 3
    CHAR            shift and go to state 4

    type_spec                      shift and go to state 7
    args                           shift and go to state 8
    type_spec_list                 shift and go to state 9
    empty                          shift and go to state 10

state 7

    (45) type_spec_list -> type_spec . ID

    ID              shift and go to state 11


state 8

    (49) funcDecl -> type_spec ID LPAREN args . RPAREN scope

    RPAREN          shift and go to state 12


state 9

    (50) args -> type_spec_list .
    (44) type_spec_list -> type_spec_list . COMMA type_spec ID

    RPAREN          reduce using rule 50 (args -> type_spec_list .)
    COMMA           shift and go to state 13


state 10

    (51) args -> empty .

    RPAREN          reduce using rule 51 (args -> empty .)


state 11

    (45) type_spec_list -> type_spec ID .

    COMMA           reduce using rule 45 (type_spec_list -> type_spec ID .)
    RPAREN          reduce using rule 45 (type_spec_list -> type_spec ID .)


state 12

    (49) funcDecl -> type_spec ID LPAREN args RPAREN . scope
    (48) scope -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 15

    scope                          shift and go to state 14

state 13

    (44) type_spec_list -> type_spec_list COMMA . type_spec ID
    (46) type_spec -> . INT
    (47) type_spec -> . CHAR

    INT             shift and go to state 3
    CHAR            shift and go to state 4

    type_spec                      shift and go to state 16

state 14

    (49) funcDecl -> type_spec ID LPAREN args RPAREN scope .

    $end            reduce using rule 49 (funcDecl -> type_spec ID LPAREN args RPAREN scope .)


state 15

    (48) scope -> LBRACE . statement_list RBRACE
    (2) statement_list -> . empty
    (3) statement_list -> . statement SEMI statement_list
    (4) statement_list -> . whileLoop statement_list
    (5) statement_list -> . if_stmt statement_list
    (1) empty -> .
    (6) statement -> . return_stmt
    (7) statement -> . var_decl
    (8) statement -> . var_assign
    (9) statement -> . goto_stmt
    (10) statement -> . break_stmt
    (11) statement -> . empty
    (52) whileLoop -> . WHILE LPAREN conditionals RPAREN scope
    (60) if_stmt -> . IF LPAREN conditionals RPAREN scope
    (61) if_stmt -> . IF LPAREN conditionals RPAREN scope elsiflist
    (25) return_stmt -> . RETURN operand
    (26) return_stmt -> . RETURN expr
    (27) return_stmt -> . RETURN var_assign
    (28) var_decl -> . type_spec ID
    (29) var_decl -> . type_spec var_assign
    (30) var_assign -> . ID EQUALS operand
    (31) var_assign -> . ID EQUALS expr
    (32) var_assign -> . ID EQUALS STRING
    (33) var_assign -> . LPAREN var_assign RPAREN
    (34) var_assign -> . ID TIMESEQUAL operand
    (35) var_assign -> . ID DIVEQUAL operand
    (36) var_assign -> . ID MODEQUAL operand
    (37) var_assign -> . ID PLUSEQUAL operand
    (38) var_assign -> . ID MINUSEQUAL operand
    (39) var_assign -> . ID LSHIFTEQUAL operand
    (40) var_assign -> . ID RSHIFTEQUAL operand
    (41) var_assign -> . ID ANDEQUAL operand
    (42) var_assign -> . ID OREQUAL operand
    (43) var_assign -> . ID XOREQUAL operand
    (59) goto_stmt -> . GOTO ID
    (58) break_stmt -> . BREAK
    (46) type_spec -> . INT
    (47) type_spec -> . CHAR

    RBRACE          reduce using rule 1 (empty -> .)
    SEMI            reduce using rule 1 (empty -> .)
    WHILE           shift and go to state 27
    IF              shift and go to state 29
    RETURN          shift and go to state 30
    ID              shift and go to state 32
    LPAREN          shift and go to state 28
    GOTO            shift and go to state 33
    BREAK           shift and go to state 34
    INT             shift and go to state 3
    CHAR            shift and go to state 4

    statement_list                 shift and go to state 17
    empty                          shift and go to state 18
    statement                      shift and go to state 19
    whileLoop                      shift and go to state 20
    if_stmt                        shift and go to state 21
    return_stmt                    shift and go to state 22
    var_decl                       shift and go to state 23
    var_assign                     shift and go to state 24
    goto_stmt                      shift and go to state 25
    break_stmt                     shift and go to state 26
    type_spec                      shift and go to state 31

state 16

    (44) type_spec_list -> type_spec_list COMMA type_spec . ID

    ID              shift and go to state 35


state 17

    (48) scope -> LBRACE statement_list . RBRACE

    RBRACE          shift and go to state 36


state 18

    (2) statement_list -> empty .
    (11) statement -> empty .

    RBRACE          reduce using rule 2 (statement_list -> empty .)
    SEMI            reduce using rule 11 (statement -> empty .)


state 19

    (3) statement_list -> statement . SEMI statement_list

    SEMI            shift and go to state 37


state 20

    (4) statement_list -> whileLoop . statement_list
    (2) statement_list -> . empty
    (3) statement_list -> . statement SEMI statement_list
    (4) statement_list -> . whileLoop statement_list
    (5) statement_list -> . if_stmt statement_list
    (1) empty -> .
    (6) statement -> . return_stmt
    (7) statement -> . var_decl
    (8) statement -> . var_assign
    (9) statement -> . goto_stmt
    (10) statement -> . break_stmt
    (11) statement -> . empty
    (52) whileLoop -> . WHILE LPAREN conditionals RPAREN scope
    (60) if_stmt -> . IF LPAREN conditionals RPAREN scope
    (61) if_stmt -> . IF LPAREN conditionals RPAREN scope elsiflist
    (25) return_stmt -> . RETURN operand
    (26) return_stmt -> . RETURN expr
    (27) return_stmt -> . RETURN var_assign
    (28) var_decl -> . type_spec ID
    (29) var_decl -> . type_spec var_assign
    (30) var_assign -> . ID EQUALS operand
    (31) var_assign -> . ID EQUALS expr
    (32) var_assign -> . ID EQUALS STRING
    (33) var_assign -> . LPAREN var_assign RPAREN
    (34) var_assign -> . ID TIMESEQUAL operand
    (35) var_assign -> . ID DIVEQUAL operand
    (36) var_assign -> . ID MODEQUAL operand
    (37) var_assign -> . ID PLUSEQUAL operand
    (38) var_assign -> . ID MINUSEQUAL operand
    (39) var_assign -> . ID LSHIFTEQUAL operand
    (40) var_assign -> . ID RSHIFTEQUAL operand
    (41) var_assign -> . ID ANDEQUAL operand
    (42) var_assign -> . ID OREQUAL operand
    (43) var_assign -> . ID XOREQUAL operand
    (59) goto_stmt -> . GOTO ID
    (58) break_stmt -> . BREAK
    (46) type_spec -> . INT
    (47) type_spec -> . CHAR

    RBRACE          reduce using rule 1 (empty -> .)
    SEMI            reduce using rule 1 (empty -> .)
    WHILE           shift and go to state 27
    IF              shift and go to state 29
    RETURN          shift and go to state 30
    ID              shift and go to state 32
    LPAREN          shift and go to state 28
    GOTO            shift and go to state 33
    BREAK           shift and go to state 34
    INT             shift and go to state 3
    CHAR            shift and go to state 4

    whileLoop                      shift and go to state 20
    statement_list                 shift and go to state 38
    empty                          shift and go to state 18
    statement                      shift and go to state 19
    if_stmt                        shift and go to state 21
    return_stmt                    shift and go to state 22
    var_decl                       shift and go to state 23
    var_assign                     shift and go to state 24
    goto_stmt                      shift and go to state 25
    break_stmt                     shift and go to state 26
    type_spec                      shift and go to state 31

state 21

    (5) statement_list -> if_stmt . statement_list
    (2) statement_list -> . empty
    (3) statement_list -> . statement SEMI statement_list
    (4) statement_list -> . whileLoop statement_list
    (5) statement_list -> . if_stmt statement_list
    (1) empty -> .
    (6) statement -> . return_stmt
    (7) statement -> . var_decl
    (8) statement -> . var_assign
    (9) statement -> . goto_stmt
    (10) statement -> . break_stmt
    (11) statement -> . empty
    (52) whileLoop -> . WHILE LPAREN conditionals RPAREN scope
    (60) if_stmt -> . IF LPAREN conditionals RPAREN scope
    (61) if_stmt -> . IF LPAREN conditionals RPAREN scope elsiflist
    (25) return_stmt -> . RETURN operand
    (26) return_stmt -> . RETURN expr
    (27) return_stmt -> . RETURN var_assign
    (28) var_decl -> . type_spec ID
    (29) var_decl -> . type_spec var_assign
    (30) var_assign -> . ID EQUALS operand
    (31) var_assign -> . ID EQUALS expr
    (32) var_assign -> . ID EQUALS STRING
    (33) var_assign -> . LPAREN var_assign RPAREN
    (34) var_assign -> . ID TIMESEQUAL operand
    (35) var_assign -> . ID DIVEQUAL operand
    (36) var_assign -> . ID MODEQUAL operand
    (37) var_assign -> . ID PLUSEQUAL operand
    (38) var_assign -> . ID MINUSEQUAL operand
    (39) var_assign -> . ID LSHIFTEQUAL operand
    (40) var_assign -> . ID RSHIFTEQUAL operand
    (41) var_assign -> . ID ANDEQUAL operand
    (42) var_assign -> . ID OREQUAL operand
    (43) var_assign -> . ID XOREQUAL operand
    (59) goto_stmt -> . GOTO ID
    (58) break_stmt -> . BREAK
    (46) type_spec -> . INT
    (47) type_spec -> . CHAR

    RBRACE          reduce using rule 1 (empty -> .)
    SEMI            reduce using rule 1 (empty -> .)
    WHILE           shift and go to state 27
    IF              shift and go to state 29
    RETURN          shift and go to state 30
    ID              shift and go to state 32
    LPAREN          shift and go to state 28
    GOTO            shift and go to state 33
    BREAK           shift and go to state 34
    INT             shift and go to state 3
    CHAR            shift and go to state 4

    if_stmt                        shift and go to state 21
    statement_list                 shift and go to state 39
    empty                          shift and go to state 18
    statement                      shift and go to state 19
    whileLoop                      shift and go to state 20
    return_stmt                    shift and go to state 22
    var_decl                       shift and go to state 23
    var_assign                     shift and go to state 24
    goto_stmt                      shift and go to state 25
    break_stmt                     shift and go to state 26
    type_spec                      shift and go to state 31

state 22

    (6) statement -> return_stmt .

    SEMI            reduce using rule 6 (statement -> return_stmt .)


state 23

    (7) statement -> var_decl .

    SEMI            reduce using rule 7 (statement -> var_decl .)


state 24

    (8) statement -> var_assign .

    SEMI            reduce using rule 8 (statement -> var_assign .)


state 25

    (9) statement -> goto_stmt .

    SEMI            reduce using rule 9 (statement -> goto_stmt .)


state 26

    (10) statement -> break_stmt .

    SEMI            reduce using rule 10 (statement -> break_stmt .)


state 27

    (52) whileLoop -> WHILE . LPAREN conditionals RPAREN scope

    LPAREN          shift and go to state 40


state 28

    (33) var_assign -> LPAREN . var_assign RPAREN
    (30) var_assign -> . ID EQUALS operand
    (31) var_assign -> . ID EQUALS expr
    (32) var_assign -> . ID EQUALS STRING
    (33) var_assign -> . LPAREN var_assign RPAREN
    (34) var_assign -> . ID TIMESEQUAL operand
    (35) var_assign -> . ID DIVEQUAL operand
    (36) var_assign -> . ID MODEQUAL operand
    (37) var_assign -> . ID PLUSEQUAL operand
    (38) var_assign -> . ID MINUSEQUAL operand
    (39) var_assign -> . ID LSHIFTEQUAL operand
    (40) var_assign -> . ID RSHIFTEQUAL operand
    (41) var_assign -> . ID ANDEQUAL operand
    (42) var_assign -> . ID OREQUAL operand
    (43) var_assign -> . ID XOREQUAL operand

    ID              shift and go to state 32
    LPAREN          shift and go to state 28

    var_assign                     shift and go to state 41

state 29

    (60) if_stmt -> IF . LPAREN conditionals RPAREN scope
    (61) if_stmt -> IF . LPAREN conditionals RPAREN scope elsiflist

    LPAREN          shift and go to state 42


state 30

    (25) return_stmt -> RETURN . operand
    (26) return_stmt -> RETURN . expr
    (27) return_stmt -> RETURN . var_assign
    (23) operand -> . ID
    (24) operand -> . NUMCONST
    (12) expr -> . expr PLUS multiplicative_expr
    (13) expr -> . expr MINUS multiplicative_expr
    (14) expr -> . multiplicative_expr
    (30) var_assign -> . ID EQUALS operand
    (31) var_assign -> . ID EQUALS expr
    (32) var_assign -> . ID EQUALS STRING
    (33) var_assign -> . LPAREN var_assign RPAREN
    (34) var_assign -> . ID TIMESEQUAL operand
    (35) var_assign -> . ID DIVEQUAL operand
    (36) var_assign -> . ID MODEQUAL operand
    (37) var_assign -> . ID PLUSEQUAL operand
    (38) var_assign -> . ID MINUSEQUAL operand
    (39) var_assign -> . ID LSHIFTEQUAL operand
    (40) var_assign -> . ID RSHIFTEQUAL operand
    (41) var_assign -> . ID ANDEQUAL operand
    (42) var_assign -> . ID OREQUAL operand
    (43) var_assign -> . ID XOREQUAL operand
    (15) multiplicative_expr -> . multiplicative_expr TIMES unary_expr
    (16) multiplicative_expr -> . multiplicative_expr DIVIDE unary_expr
    (17) multiplicative_expr -> . multiplicative_expr MODULO unary_expr
    (18) multiplicative_expr -> . unary_expr
    (19) unary_expr -> . INCREMENT operand
    (20) unary_expr -> . DECREMENT operand
    (21) unary_expr -> . operand INCREMENT
    (22) unary_expr -> . operand DECREMENT

    ID              shift and go to state 46
    NUMCONST        shift and go to state 47
    LPAREN          shift and go to state 28
    INCREMENT       shift and go to state 50
    DECREMENT       shift and go to state 51

    operand                        shift and go to state 43
    expr                           shift and go to state 44
    var_assign                     shift and go to state 45
    multiplicative_expr            shift and go to state 48
    unary_expr                     shift and go to state 49

state 31

    (28) var_decl -> type_spec . ID
    (29) var_decl -> type_spec . var_assign
    (30) var_assign -> . ID EQUALS operand
    (31) var_assign -> . ID EQUALS expr
    (32) var_assign -> . ID EQUALS STRING
    (33) var_assign -> . LPAREN var_assign RPAREN
    (34) var_assign -> . ID TIMESEQUAL operand
    (35) var_assign -> . ID DIVEQUAL operand
    (36) var_assign -> . ID MODEQUAL operand
    (37) var_assign -> . ID PLUSEQUAL operand
    (38) var_assign -> . ID MINUSEQUAL operand
    (39) var_assign -> . ID LSHIFTEQUAL operand
    (40) var_assign -> . ID RSHIFTEQUAL operand
    (41) var_assign -> . ID ANDEQUAL operand
    (42) var_assign -> . ID OREQUAL operand
    (43) var_assign -> . ID XOREQUAL operand

    ID              shift and go to state 52
    LPAREN          shift and go to state 28

    var_assign                     shift and go to state 53

state 32

    (30) var_assign -> ID . EQUALS operand
    (31) var_assign -> ID . EQUALS expr
    (32) var_assign -> ID . EQUALS STRING
    (34) var_assign -> ID . TIMESEQUAL operand
    (35) var_assign -> ID . DIVEQUAL operand
    (36) var_assign -> ID . MODEQUAL operand
    (37) var_assign -> ID . PLUSEQUAL operand
    (38) var_assign -> ID . MINUSEQUAL operand
    (39) var_assign -> ID . LSHIFTEQUAL operand
    (40) var_assign -> ID . RSHIFTEQUAL operand
    (41) var_assign -> ID . ANDEQUAL operand
    (42) var_assign -> ID . OREQUAL operand
    (43) var_assign -> ID . XOREQUAL operand

    EQUALS          shift and go to state 54
    TIMESEQUAL      shift and go to state 55
    DIVEQUAL        shift and go to state 56
    MODEQUAL        shift and go to state 57
    PLUSEQUAL       shift and go to state 58
    MINUSEQUAL      shift and go to state 59
    LSHIFTEQUAL     shift and go to state 60
    RSHIFTEQUAL     shift and go to state 61
    ANDEQUAL        shift and go to state 62
    OREQUAL         shift and go to state 63
    XOREQUAL        shift and go to state 64


state 33

    (59) goto_stmt -> GOTO . ID

    ID              shift and go to state 65


state 34

    (58) break_stmt -> BREAK .

    SEMI            reduce using rule 58 (break_stmt -> BREAK .)


state 35

    (44) type_spec_list -> type_spec_list COMMA type_spec ID .

    COMMA           reduce using rule 44 (type_spec_list -> type_spec_list COMMA type_spec ID .)
    RPAREN          reduce using rule 44 (type_spec_list -> type_spec_list COMMA type_spec ID .)


state 36

    (48) scope -> LBRACE statement_list RBRACE .

    $end            reduce using rule 48 (scope -> LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 48 (scope -> LBRACE statement_list RBRACE .)
    IF              reduce using rule 48 (scope -> LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 48 (scope -> LBRACE statement_list RBRACE .)
    ID              reduce using rule 48 (scope -> LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 48 (scope -> LBRACE statement_list RBRACE .)
    GOTO            reduce using rule 48 (scope -> LBRACE statement_list RBRACE .)
    BREAK           reduce using rule 48 (scope -> LBRACE statement_list RBRACE .)
    INT             reduce using rule 48 (scope -> LBRACE statement_list RBRACE .)
    CHAR            reduce using rule 48 (scope -> LBRACE statement_list RBRACE .)
    SEMI            reduce using rule 48 (scope -> LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 48 (scope -> LBRACE statement_list RBRACE .)
    ELSE            reduce using rule 48 (scope -> LBRACE statement_list RBRACE .)


state 37

    (3) statement_list -> statement SEMI . statement_list
    (2) statement_list -> . empty
    (3) statement_list -> . statement SEMI statement_list
    (4) statement_list -> . whileLoop statement_list
    (5) statement_list -> . if_stmt statement_list
    (1) empty -> .
    (6) statement -> . return_stmt
    (7) statement -> . var_decl
    (8) statement -> . var_assign
    (9) statement -> . goto_stmt
    (10) statement -> . break_stmt
    (11) statement -> . empty
    (52) whileLoop -> . WHILE LPAREN conditionals RPAREN scope
    (60) if_stmt -> . IF LPAREN conditionals RPAREN scope
    (61) if_stmt -> . IF LPAREN conditionals RPAREN scope elsiflist
    (25) return_stmt -> . RETURN operand
    (26) return_stmt -> . RETURN expr
    (27) return_stmt -> . RETURN var_assign
    (28) var_decl -> . type_spec ID
    (29) var_decl -> . type_spec var_assign
    (30) var_assign -> . ID EQUALS operand
    (31) var_assign -> . ID EQUALS expr
    (32) var_assign -> . ID EQUALS STRING
    (33) var_assign -> . LPAREN var_assign RPAREN
    (34) var_assign -> . ID TIMESEQUAL operand
    (35) var_assign -> . ID DIVEQUAL operand
    (36) var_assign -> . ID MODEQUAL operand
    (37) var_assign -> . ID PLUSEQUAL operand
    (38) var_assign -> . ID MINUSEQUAL operand
    (39) var_assign -> . ID LSHIFTEQUAL operand
    (40) var_assign -> . ID RSHIFTEQUAL operand
    (41) var_assign -> . ID ANDEQUAL operand
    (42) var_assign -> . ID OREQUAL operand
    (43) var_assign -> . ID XOREQUAL operand
    (59) goto_stmt -> . GOTO ID
    (58) break_stmt -> . BREAK
    (46) type_spec -> . INT
    (47) type_spec -> . CHAR

    RBRACE          reduce using rule 1 (empty -> .)
    SEMI            reduce using rule 1 (empty -> .)
    WHILE           shift and go to state 27
    IF              shift and go to state 29
    RETURN          shift and go to state 30
    ID              shift and go to state 32
    LPAREN          shift and go to state 28
    GOTO            shift and go to state 33
    BREAK           shift and go to state 34
    INT             shift and go to state 3
    CHAR            shift and go to state 4

    statement                      shift and go to state 19
    statement_list                 shift and go to state 66
    empty                          shift and go to state 18
    whileLoop                      shift and go to state 20
    if_stmt                        shift and go to state 21
    return_stmt                    shift and go to state 22
    var_decl                       shift and go to state 23
    var_assign                     shift and go to state 24
    goto_stmt                      shift and go to state 25
    break_stmt                     shift and go to state 26
    type_spec                      shift and go to state 31

state 38

    (4) statement_list -> whileLoop statement_list .

    RBRACE          reduce using rule 4 (statement_list -> whileLoop statement_list .)


state 39

    (5) statement_list -> if_stmt statement_list .

    RBRACE          reduce using rule 5 (statement_list -> if_stmt statement_list .)


state 40

    (52) whileLoop -> WHILE LPAREN . conditionals RPAREN scope
    (53) conditionals -> . operand compOps operand
    (23) operand -> . ID
    (24) operand -> . NUMCONST

    ID              shift and go to state 69
    NUMCONST        shift and go to state 47

    conditionals                   shift and go to state 67
    operand                        shift and go to state 68

state 41

    (33) var_assign -> LPAREN var_assign . RPAREN

    RPAREN          shift and go to state 70


state 42

    (60) if_stmt -> IF LPAREN . conditionals RPAREN scope
    (61) if_stmt -> IF LPAREN . conditionals RPAREN scope elsiflist
    (53) conditionals -> . operand compOps operand
    (23) operand -> . ID
    (24) operand -> . NUMCONST

    ID              shift and go to state 69
    NUMCONST        shift and go to state 47

    conditionals                   shift and go to state 71
    operand                        shift and go to state 68

state 43

    (25) return_stmt -> RETURN operand .
    (21) unary_expr -> operand . INCREMENT
    (22) unary_expr -> operand . DECREMENT

    SEMI            reduce using rule 25 (return_stmt -> RETURN operand .)
    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73


state 44

    (26) return_stmt -> RETURN expr .
    (12) expr -> expr . PLUS multiplicative_expr
    (13) expr -> expr . MINUS multiplicative_expr

    SEMI            reduce using rule 26 (return_stmt -> RETURN expr .)
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 45

    (27) return_stmt -> RETURN var_assign .

    SEMI            reduce using rule 27 (return_stmt -> RETURN var_assign .)


state 46

    (23) operand -> ID .
    (30) var_assign -> ID . EQUALS operand
    (31) var_assign -> ID . EQUALS expr
    (32) var_assign -> ID . EQUALS STRING
    (34) var_assign -> ID . TIMESEQUAL operand
    (35) var_assign -> ID . DIVEQUAL operand
    (36) var_assign -> ID . MODEQUAL operand
    (37) var_assign -> ID . PLUSEQUAL operand
    (38) var_assign -> ID . MINUSEQUAL operand
    (39) var_assign -> ID . LSHIFTEQUAL operand
    (40) var_assign -> ID . RSHIFTEQUAL operand
    (41) var_assign -> ID . ANDEQUAL operand
    (42) var_assign -> ID . OREQUAL operand
    (43) var_assign -> ID . XOREQUAL operand

    INCREMENT       reduce using rule 23 (operand -> ID .)
    DECREMENT       reduce using rule 23 (operand -> ID .)
    SEMI            reduce using rule 23 (operand -> ID .)
    EQUALS          shift and go to state 54
    TIMESEQUAL      shift and go to state 55
    DIVEQUAL        shift and go to state 56
    MODEQUAL        shift and go to state 57
    PLUSEQUAL       shift and go to state 58
    MINUSEQUAL      shift and go to state 59
    LSHIFTEQUAL     shift and go to state 60
    RSHIFTEQUAL     shift and go to state 61
    ANDEQUAL        shift and go to state 62
    OREQUAL         shift and go to state 63
    XOREQUAL        shift and go to state 64


state 47

    (24) operand -> NUMCONST .

    INCREMENT       reduce using rule 24 (operand -> NUMCONST .)
    DECREMENT       reduce using rule 24 (operand -> NUMCONST .)
    SEMI            reduce using rule 24 (operand -> NUMCONST .)
    LE              reduce using rule 24 (operand -> NUMCONST .)
    GE              reduce using rule 24 (operand -> NUMCONST .)
    EQ              reduce using rule 24 (operand -> NUMCONST .)
    NE              reduce using rule 24 (operand -> NUMCONST .)
    TIMES           reduce using rule 24 (operand -> NUMCONST .)
    DIVIDE          reduce using rule 24 (operand -> NUMCONST .)
    MODULO          reduce using rule 24 (operand -> NUMCONST .)
    PLUS            reduce using rule 24 (operand -> NUMCONST .)
    MINUS           reduce using rule 24 (operand -> NUMCONST .)
    RPAREN          reduce using rule 24 (operand -> NUMCONST .)


state 48

    (14) expr -> multiplicative_expr .
    (15) multiplicative_expr -> multiplicative_expr . TIMES unary_expr
    (16) multiplicative_expr -> multiplicative_expr . DIVIDE unary_expr
    (17) multiplicative_expr -> multiplicative_expr . MODULO unary_expr

    PLUS            reduce using rule 14 (expr -> multiplicative_expr .)
    MINUS           reduce using rule 14 (expr -> multiplicative_expr .)
    SEMI            reduce using rule 14 (expr -> multiplicative_expr .)
    RPAREN          reduce using rule 14 (expr -> multiplicative_expr .)
    TIMES           shift and go to state 76
    DIVIDE          shift and go to state 77
    MODULO          shift and go to state 78


state 49

    (18) multiplicative_expr -> unary_expr .

    TIMES           reduce using rule 18 (multiplicative_expr -> unary_expr .)
    DIVIDE          reduce using rule 18 (multiplicative_expr -> unary_expr .)
    MODULO          reduce using rule 18 (multiplicative_expr -> unary_expr .)
    PLUS            reduce using rule 18 (multiplicative_expr -> unary_expr .)
    MINUS           reduce using rule 18 (multiplicative_expr -> unary_expr .)
    SEMI            reduce using rule 18 (multiplicative_expr -> unary_expr .)
    RPAREN          reduce using rule 18 (multiplicative_expr -> unary_expr .)


state 50

    (19) unary_expr -> INCREMENT . operand
    (23) operand -> . ID
    (24) operand -> . NUMCONST

    ID              shift and go to state 69
    NUMCONST        shift and go to state 47

    operand                        shift and go to state 79

state 51

    (20) unary_expr -> DECREMENT . operand
    (23) operand -> . ID
    (24) operand -> . NUMCONST

    ID              shift and go to state 69
    NUMCONST        shift and go to state 47

    operand                        shift and go to state 80

state 52

    (28) var_decl -> type_spec ID .
    (30) var_assign -> ID . EQUALS operand
    (31) var_assign -> ID . EQUALS expr
    (32) var_assign -> ID . EQUALS STRING
    (34) var_assign -> ID . TIMESEQUAL operand
    (35) var_assign -> ID . DIVEQUAL operand
    (36) var_assign -> ID . MODEQUAL operand
    (37) var_assign -> ID . PLUSEQUAL operand
    (38) var_assign -> ID . MINUSEQUAL operand
    (39) var_assign -> ID . LSHIFTEQUAL operand
    (40) var_assign -> ID . RSHIFTEQUAL operand
    (41) var_assign -> ID . ANDEQUAL operand
    (42) var_assign -> ID . OREQUAL operand
    (43) var_assign -> ID . XOREQUAL operand

    SEMI            reduce using rule 28 (var_decl -> type_spec ID .)
    EQUALS          shift and go to state 54
    TIMESEQUAL      shift and go to state 55
    DIVEQUAL        shift and go to state 56
    MODEQUAL        shift and go to state 57
    PLUSEQUAL       shift and go to state 58
    MINUSEQUAL      shift and go to state 59
    LSHIFTEQUAL     shift and go to state 60
    RSHIFTEQUAL     shift and go to state 61
    ANDEQUAL        shift and go to state 62
    OREQUAL         shift and go to state 63
    XOREQUAL        shift and go to state 64


state 53

    (29) var_decl -> type_spec var_assign .

    SEMI            reduce using rule 29 (var_decl -> type_spec var_assign .)


state 54

    (30) var_assign -> ID EQUALS . operand
    (31) var_assign -> ID EQUALS . expr
    (32) var_assign -> ID EQUALS . STRING
    (23) operand -> . ID
    (24) operand -> . NUMCONST
    (12) expr -> . expr PLUS multiplicative_expr
    (13) expr -> . expr MINUS multiplicative_expr
    (14) expr -> . multiplicative_expr
    (15) multiplicative_expr -> . multiplicative_expr TIMES unary_expr
    (16) multiplicative_expr -> . multiplicative_expr DIVIDE unary_expr
    (17) multiplicative_expr -> . multiplicative_expr MODULO unary_expr
    (18) multiplicative_expr -> . unary_expr
    (19) unary_expr -> . INCREMENT operand
    (20) unary_expr -> . DECREMENT operand
    (21) unary_expr -> . operand INCREMENT
    (22) unary_expr -> . operand DECREMENT

    STRING          shift and go to state 83
    ID              shift and go to state 69
    NUMCONST        shift and go to state 47
    INCREMENT       shift and go to state 50
    DECREMENT       shift and go to state 51

    operand                        shift and go to state 81
    expr                           shift and go to state 82
    multiplicative_expr            shift and go to state 48
    unary_expr                     shift and go to state 49

state 55

    (34) var_assign -> ID TIMESEQUAL . operand
    (23) operand -> . ID
    (24) operand -> . NUMCONST

    ID              shift and go to state 69
    NUMCONST        shift and go to state 47

    operand                        shift and go to state 84

state 56

    (35) var_assign -> ID DIVEQUAL . operand
    (23) operand -> . ID
    (24) operand -> . NUMCONST

    ID              shift and go to state 69
    NUMCONST        shift and go to state 47

    operand                        shift and go to state 85

state 57

    (36) var_assign -> ID MODEQUAL . operand
    (23) operand -> . ID
    (24) operand -> . NUMCONST

    ID              shift and go to state 69
    NUMCONST        shift and go to state 47

    operand                        shift and go to state 86

state 58

    (37) var_assign -> ID PLUSEQUAL . operand
    (23) operand -> . ID
    (24) operand -> . NUMCONST

    ID              shift and go to state 69
    NUMCONST        shift and go to state 47

    operand                        shift and go to state 87

state 59

    (38) var_assign -> ID MINUSEQUAL . operand
    (23) operand -> . ID
    (24) operand -> . NUMCONST

    ID              shift and go to state 69
    NUMCONST        shift and go to state 47

    operand                        shift and go to state 88

state 60

    (39) var_assign -> ID LSHIFTEQUAL . operand
    (23) operand -> . ID
    (24) operand -> . NUMCONST

    ID              shift and go to state 69
    NUMCONST        shift and go to state 47

    operand                        shift and go to state 89

state 61

    (40) var_assign -> ID RSHIFTEQUAL . operand
    (23) operand -> . ID
    (24) operand -> . NUMCONST

    ID              shift and go to state 69
    NUMCONST        shift and go to state 47

    operand                        shift and go to state 90

state 62

    (41) var_assign -> ID ANDEQUAL . operand
    (23) operand -> . ID
    (24) operand -> . NUMCONST

    ID              shift and go to state 69
    NUMCONST        shift and go to state 47

    operand                        shift and go to state 91

state 63

    (42) var_assign -> ID OREQUAL . operand
    (23) operand -> . ID
    (24) operand -> . NUMCONST

    ID              shift and go to state 69
    NUMCONST        shift and go to state 47

    operand                        shift and go to state 92

state 64

    (43) var_assign -> ID XOREQUAL . operand
    (23) operand -> . ID
    (24) operand -> . NUMCONST

    ID              shift and go to state 69
    NUMCONST        shift and go to state 47

    operand                        shift and go to state 93

state 65

    (59) goto_stmt -> GOTO ID .

    SEMI            reduce using rule 59 (goto_stmt -> GOTO ID .)


state 66

    (3) statement_list -> statement SEMI statement_list .

    RBRACE          reduce using rule 3 (statement_list -> statement SEMI statement_list .)


state 67

    (52) whileLoop -> WHILE LPAREN conditionals . RPAREN scope

    RPAREN          shift and go to state 94


state 68

    (53) conditionals -> operand . compOps operand
    (54) compOps -> . LE
    (55) compOps -> . GE
    (56) compOps -> . EQ
    (57) compOps -> . NE

    LE              shift and go to state 96
    GE              shift and go to state 97
    EQ              shift and go to state 98
    NE              shift and go to state 99

    compOps                        shift and go to state 95

state 69

    (23) operand -> ID .

    LE              reduce using rule 23 (operand -> ID .)
    GE              reduce using rule 23 (operand -> ID .)
    EQ              reduce using rule 23 (operand -> ID .)
    NE              reduce using rule 23 (operand -> ID .)
    TIMES           reduce using rule 23 (operand -> ID .)
    DIVIDE          reduce using rule 23 (operand -> ID .)
    MODULO          reduce using rule 23 (operand -> ID .)
    PLUS            reduce using rule 23 (operand -> ID .)
    MINUS           reduce using rule 23 (operand -> ID .)
    SEMI            reduce using rule 23 (operand -> ID .)
    RPAREN          reduce using rule 23 (operand -> ID .)
    INCREMENT       reduce using rule 23 (operand -> ID .)
    DECREMENT       reduce using rule 23 (operand -> ID .)


state 70

    (33) var_assign -> LPAREN var_assign RPAREN .

    SEMI            reduce using rule 33 (var_assign -> LPAREN var_assign RPAREN .)
    RPAREN          reduce using rule 33 (var_assign -> LPAREN var_assign RPAREN .)


state 71

    (60) if_stmt -> IF LPAREN conditionals . RPAREN scope
    (61) if_stmt -> IF LPAREN conditionals . RPAREN scope elsiflist

    RPAREN          shift and go to state 100


state 72

    (21) unary_expr -> operand INCREMENT .

    TIMES           reduce using rule 21 (unary_expr -> operand INCREMENT .)
    DIVIDE          reduce using rule 21 (unary_expr -> operand INCREMENT .)
    MODULO          reduce using rule 21 (unary_expr -> operand INCREMENT .)
    PLUS            reduce using rule 21 (unary_expr -> operand INCREMENT .)
    MINUS           reduce using rule 21 (unary_expr -> operand INCREMENT .)
    SEMI            reduce using rule 21 (unary_expr -> operand INCREMENT .)
    RPAREN          reduce using rule 21 (unary_expr -> operand INCREMENT .)


state 73

    (22) unary_expr -> operand DECREMENT .

    TIMES           reduce using rule 22 (unary_expr -> operand DECREMENT .)
    DIVIDE          reduce using rule 22 (unary_expr -> operand DECREMENT .)
    MODULO          reduce using rule 22 (unary_expr -> operand DECREMENT .)
    PLUS            reduce using rule 22 (unary_expr -> operand DECREMENT .)
    MINUS           reduce using rule 22 (unary_expr -> operand DECREMENT .)
    SEMI            reduce using rule 22 (unary_expr -> operand DECREMENT .)
    RPAREN          reduce using rule 22 (unary_expr -> operand DECREMENT .)


state 74

    (12) expr -> expr PLUS . multiplicative_expr
    (15) multiplicative_expr -> . multiplicative_expr TIMES unary_expr
    (16) multiplicative_expr -> . multiplicative_expr DIVIDE unary_expr
    (17) multiplicative_expr -> . multiplicative_expr MODULO unary_expr
    (18) multiplicative_expr -> . unary_expr
    (19) unary_expr -> . INCREMENT operand
    (20) unary_expr -> . DECREMENT operand
    (21) unary_expr -> . operand INCREMENT
    (22) unary_expr -> . operand DECREMENT
    (23) operand -> . ID
    (24) operand -> . NUMCONST

    INCREMENT       shift and go to state 50
    DECREMENT       shift and go to state 51
    ID              shift and go to state 69
    NUMCONST        shift and go to state 47

    multiplicative_expr            shift and go to state 101
    unary_expr                     shift and go to state 49
    operand                        shift and go to state 102

state 75

    (13) expr -> expr MINUS . multiplicative_expr
    (15) multiplicative_expr -> . multiplicative_expr TIMES unary_expr
    (16) multiplicative_expr -> . multiplicative_expr DIVIDE unary_expr
    (17) multiplicative_expr -> . multiplicative_expr MODULO unary_expr
    (18) multiplicative_expr -> . unary_expr
    (19) unary_expr -> . INCREMENT operand
    (20) unary_expr -> . DECREMENT operand
    (21) unary_expr -> . operand INCREMENT
    (22) unary_expr -> . operand DECREMENT
    (23) operand -> . ID
    (24) operand -> . NUMCONST

    INCREMENT       shift and go to state 50
    DECREMENT       shift and go to state 51
    ID              shift and go to state 69
    NUMCONST        shift and go to state 47

    multiplicative_expr            shift and go to state 103
    unary_expr                     shift and go to state 49
    operand                        shift and go to state 102

state 76

    (15) multiplicative_expr -> multiplicative_expr TIMES . unary_expr
    (19) unary_expr -> . INCREMENT operand
    (20) unary_expr -> . DECREMENT operand
    (21) unary_expr -> . operand INCREMENT
    (22) unary_expr -> . operand DECREMENT
    (23) operand -> . ID
    (24) operand -> . NUMCONST

    INCREMENT       shift and go to state 50
    DECREMENT       shift and go to state 51
    ID              shift and go to state 69
    NUMCONST        shift and go to state 47

    unary_expr                     shift and go to state 104
    operand                        shift and go to state 102

state 77

    (16) multiplicative_expr -> multiplicative_expr DIVIDE . unary_expr
    (19) unary_expr -> . INCREMENT operand
    (20) unary_expr -> . DECREMENT operand
    (21) unary_expr -> . operand INCREMENT
    (22) unary_expr -> . operand DECREMENT
    (23) operand -> . ID
    (24) operand -> . NUMCONST

    INCREMENT       shift and go to state 50
    DECREMENT       shift and go to state 51
    ID              shift and go to state 69
    NUMCONST        shift and go to state 47

    unary_expr                     shift and go to state 105
    operand                        shift and go to state 102

state 78

    (17) multiplicative_expr -> multiplicative_expr MODULO . unary_expr
    (19) unary_expr -> . INCREMENT operand
    (20) unary_expr -> . DECREMENT operand
    (21) unary_expr -> . operand INCREMENT
    (22) unary_expr -> . operand DECREMENT
    (23) operand -> . ID
    (24) operand -> . NUMCONST

    INCREMENT       shift and go to state 50
    DECREMENT       shift and go to state 51
    ID              shift and go to state 69
    NUMCONST        shift and go to state 47

    unary_expr                     shift and go to state 106
    operand                        shift and go to state 102

state 79

    (19) unary_expr -> INCREMENT operand .

    TIMES           reduce using rule 19 (unary_expr -> INCREMENT operand .)
    DIVIDE          reduce using rule 19 (unary_expr -> INCREMENT operand .)
    MODULO          reduce using rule 19 (unary_expr -> INCREMENT operand .)
    PLUS            reduce using rule 19 (unary_expr -> INCREMENT operand .)
    MINUS           reduce using rule 19 (unary_expr -> INCREMENT operand .)
    SEMI            reduce using rule 19 (unary_expr -> INCREMENT operand .)
    RPAREN          reduce using rule 19 (unary_expr -> INCREMENT operand .)


state 80

    (20) unary_expr -> DECREMENT operand .

    TIMES           reduce using rule 20 (unary_expr -> DECREMENT operand .)
    DIVIDE          reduce using rule 20 (unary_expr -> DECREMENT operand .)
    MODULO          reduce using rule 20 (unary_expr -> DECREMENT operand .)
    PLUS            reduce using rule 20 (unary_expr -> DECREMENT operand .)
    MINUS           reduce using rule 20 (unary_expr -> DECREMENT operand .)
    SEMI            reduce using rule 20 (unary_expr -> DECREMENT operand .)
    RPAREN          reduce using rule 20 (unary_expr -> DECREMENT operand .)


state 81

    (30) var_assign -> ID EQUALS operand .
    (21) unary_expr -> operand . INCREMENT
    (22) unary_expr -> operand . DECREMENT

    SEMI            reduce using rule 30 (var_assign -> ID EQUALS operand .)
    RPAREN          reduce using rule 30 (var_assign -> ID EQUALS operand .)
    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73


state 82

    (31) var_assign -> ID EQUALS expr .
    (12) expr -> expr . PLUS multiplicative_expr
    (13) expr -> expr . MINUS multiplicative_expr

    SEMI            reduce using rule 31 (var_assign -> ID EQUALS expr .)
    RPAREN          reduce using rule 31 (var_assign -> ID EQUALS expr .)
    PLUS            shift and go to state 74
    MINUS           shift and go to state 75


state 83

    (32) var_assign -> ID EQUALS STRING .

    SEMI            reduce using rule 32 (var_assign -> ID EQUALS STRING .)
    RPAREN          reduce using rule 32 (var_assign -> ID EQUALS STRING .)


state 84

    (34) var_assign -> ID TIMESEQUAL operand .

    SEMI            reduce using rule 34 (var_assign -> ID TIMESEQUAL operand .)
    RPAREN          reduce using rule 34 (var_assign -> ID TIMESEQUAL operand .)


state 85

    (35) var_assign -> ID DIVEQUAL operand .

    SEMI            reduce using rule 35 (var_assign -> ID DIVEQUAL operand .)
    RPAREN          reduce using rule 35 (var_assign -> ID DIVEQUAL operand .)


state 86

    (36) var_assign -> ID MODEQUAL operand .

    SEMI            reduce using rule 36 (var_assign -> ID MODEQUAL operand .)
    RPAREN          reduce using rule 36 (var_assign -> ID MODEQUAL operand .)


state 87

    (37) var_assign -> ID PLUSEQUAL operand .

    SEMI            reduce using rule 37 (var_assign -> ID PLUSEQUAL operand .)
    RPAREN          reduce using rule 37 (var_assign -> ID PLUSEQUAL operand .)


state 88

    (38) var_assign -> ID MINUSEQUAL operand .

    SEMI            reduce using rule 38 (var_assign -> ID MINUSEQUAL operand .)
    RPAREN          reduce using rule 38 (var_assign -> ID MINUSEQUAL operand .)


state 89

    (39) var_assign -> ID LSHIFTEQUAL operand .

    SEMI            reduce using rule 39 (var_assign -> ID LSHIFTEQUAL operand .)
    RPAREN          reduce using rule 39 (var_assign -> ID LSHIFTEQUAL operand .)


state 90

    (40) var_assign -> ID RSHIFTEQUAL operand .

    SEMI            reduce using rule 40 (var_assign -> ID RSHIFTEQUAL operand .)
    RPAREN          reduce using rule 40 (var_assign -> ID RSHIFTEQUAL operand .)


state 91

    (41) var_assign -> ID ANDEQUAL operand .

    SEMI            reduce using rule 41 (var_assign -> ID ANDEQUAL operand .)
    RPAREN          reduce using rule 41 (var_assign -> ID ANDEQUAL operand .)


state 92

    (42) var_assign -> ID OREQUAL operand .

    SEMI            reduce using rule 42 (var_assign -> ID OREQUAL operand .)
    RPAREN          reduce using rule 42 (var_assign -> ID OREQUAL operand .)


state 93

    (43) var_assign -> ID XOREQUAL operand .

    SEMI            reduce using rule 43 (var_assign -> ID XOREQUAL operand .)
    RPAREN          reduce using rule 43 (var_assign -> ID XOREQUAL operand .)


state 94

    (52) whileLoop -> WHILE LPAREN conditionals RPAREN . scope
    (48) scope -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 15

    scope                          shift and go to state 107

state 95

    (53) conditionals -> operand compOps . operand
    (23) operand -> . ID
    (24) operand -> . NUMCONST

    ID              shift and go to state 69
    NUMCONST        shift and go to state 47

    operand                        shift and go to state 108

state 96

    (54) compOps -> LE .

    ID              reduce using rule 54 (compOps -> LE .)
    NUMCONST        reduce using rule 54 (compOps -> LE .)


state 97

    (55) compOps -> GE .

    ID              reduce using rule 55 (compOps -> GE .)
    NUMCONST        reduce using rule 55 (compOps -> GE .)


state 98

    (56) compOps -> EQ .

    ID              reduce using rule 56 (compOps -> EQ .)
    NUMCONST        reduce using rule 56 (compOps -> EQ .)


state 99

    (57) compOps -> NE .

    ID              reduce using rule 57 (compOps -> NE .)
    NUMCONST        reduce using rule 57 (compOps -> NE .)


state 100

    (60) if_stmt -> IF LPAREN conditionals RPAREN . scope
    (61) if_stmt -> IF LPAREN conditionals RPAREN . scope elsiflist
    (48) scope -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 15

    scope                          shift and go to state 109

state 101

    (12) expr -> expr PLUS multiplicative_expr .
    (15) multiplicative_expr -> multiplicative_expr . TIMES unary_expr
    (16) multiplicative_expr -> multiplicative_expr . DIVIDE unary_expr
    (17) multiplicative_expr -> multiplicative_expr . MODULO unary_expr

    PLUS            reduce using rule 12 (expr -> expr PLUS multiplicative_expr .)
    MINUS           reduce using rule 12 (expr -> expr PLUS multiplicative_expr .)
    SEMI            reduce using rule 12 (expr -> expr PLUS multiplicative_expr .)
    RPAREN          reduce using rule 12 (expr -> expr PLUS multiplicative_expr .)
    TIMES           shift and go to state 76
    DIVIDE          shift and go to state 77
    MODULO          shift and go to state 78


state 102

    (21) unary_expr -> operand . INCREMENT
    (22) unary_expr -> operand . DECREMENT

    INCREMENT       shift and go to state 72
    DECREMENT       shift and go to state 73


state 103

    (13) expr -> expr MINUS multiplicative_expr .
    (15) multiplicative_expr -> multiplicative_expr . TIMES unary_expr
    (16) multiplicative_expr -> multiplicative_expr . DIVIDE unary_expr
    (17) multiplicative_expr -> multiplicative_expr . MODULO unary_expr

    PLUS            reduce using rule 13 (expr -> expr MINUS multiplicative_expr .)
    MINUS           reduce using rule 13 (expr -> expr MINUS multiplicative_expr .)
    SEMI            reduce using rule 13 (expr -> expr MINUS multiplicative_expr .)
    RPAREN          reduce using rule 13 (expr -> expr MINUS multiplicative_expr .)
    TIMES           shift and go to state 76
    DIVIDE          shift and go to state 77
    MODULO          shift and go to state 78


state 104

    (15) multiplicative_expr -> multiplicative_expr TIMES unary_expr .

    TIMES           reduce using rule 15 (multiplicative_expr -> multiplicative_expr TIMES unary_expr .)
    DIVIDE          reduce using rule 15 (multiplicative_expr -> multiplicative_expr TIMES unary_expr .)
    MODULO          reduce using rule 15 (multiplicative_expr -> multiplicative_expr TIMES unary_expr .)
    PLUS            reduce using rule 15 (multiplicative_expr -> multiplicative_expr TIMES unary_expr .)
    MINUS           reduce using rule 15 (multiplicative_expr -> multiplicative_expr TIMES unary_expr .)
    SEMI            reduce using rule 15 (multiplicative_expr -> multiplicative_expr TIMES unary_expr .)
    RPAREN          reduce using rule 15 (multiplicative_expr -> multiplicative_expr TIMES unary_expr .)


state 105

    (16) multiplicative_expr -> multiplicative_expr DIVIDE unary_expr .

    TIMES           reduce using rule 16 (multiplicative_expr -> multiplicative_expr DIVIDE unary_expr .)
    DIVIDE          reduce using rule 16 (multiplicative_expr -> multiplicative_expr DIVIDE unary_expr .)
    MODULO          reduce using rule 16 (multiplicative_expr -> multiplicative_expr DIVIDE unary_expr .)
    PLUS            reduce using rule 16 (multiplicative_expr -> multiplicative_expr DIVIDE unary_expr .)
    MINUS           reduce using rule 16 (multiplicative_expr -> multiplicative_expr DIVIDE unary_expr .)
    SEMI            reduce using rule 16 (multiplicative_expr -> multiplicative_expr DIVIDE unary_expr .)
    RPAREN          reduce using rule 16 (multiplicative_expr -> multiplicative_expr DIVIDE unary_expr .)


state 106

    (17) multiplicative_expr -> multiplicative_expr MODULO unary_expr .

    TIMES           reduce using rule 17 (multiplicative_expr -> multiplicative_expr MODULO unary_expr .)
    DIVIDE          reduce using rule 17 (multiplicative_expr -> multiplicative_expr MODULO unary_expr .)
    MODULO          reduce using rule 17 (multiplicative_expr -> multiplicative_expr MODULO unary_expr .)
    PLUS            reduce using rule 17 (multiplicative_expr -> multiplicative_expr MODULO unary_expr .)
    MINUS           reduce using rule 17 (multiplicative_expr -> multiplicative_expr MODULO unary_expr .)
    SEMI            reduce using rule 17 (multiplicative_expr -> multiplicative_expr MODULO unary_expr .)
    RPAREN          reduce using rule 17 (multiplicative_expr -> multiplicative_expr MODULO unary_expr .)


state 107

    (52) whileLoop -> WHILE LPAREN conditionals RPAREN scope .

    WHILE           reduce using rule 52 (whileLoop -> WHILE LPAREN conditionals RPAREN scope .)
    IF              reduce using rule 52 (whileLoop -> WHILE LPAREN conditionals RPAREN scope .)
    RETURN          reduce using rule 52 (whileLoop -> WHILE LPAREN conditionals RPAREN scope .)
    ID              reduce using rule 52 (whileLoop -> WHILE LPAREN conditionals RPAREN scope .)
    LPAREN          reduce using rule 52 (whileLoop -> WHILE LPAREN conditionals RPAREN scope .)
    GOTO            reduce using rule 52 (whileLoop -> WHILE LPAREN conditionals RPAREN scope .)
    BREAK           reduce using rule 52 (whileLoop -> WHILE LPAREN conditionals RPAREN scope .)
    INT             reduce using rule 52 (whileLoop -> WHILE LPAREN conditionals RPAREN scope .)
    CHAR            reduce using rule 52 (whileLoop -> WHILE LPAREN conditionals RPAREN scope .)
    SEMI            reduce using rule 52 (whileLoop -> WHILE LPAREN conditionals RPAREN scope .)
    RBRACE          reduce using rule 52 (whileLoop -> WHILE LPAREN conditionals RPAREN scope .)


state 108

    (53) conditionals -> operand compOps operand .

    RPAREN          reduce using rule 53 (conditionals -> operand compOps operand .)


state 109

    (60) if_stmt -> IF LPAREN conditionals RPAREN scope .
    (61) if_stmt -> IF LPAREN conditionals RPAREN scope . elsiflist
    (62) elsiflist -> . ELSE IF LPAREN conditionals RPAREN scope elsiflist
    (63) elsiflist -> . ELSE IF LPAREN conditionals RPAREN scope empty
    (64) elsiflist -> . ELSE scope

    WHILE           reduce using rule 60 (if_stmt -> IF LPAREN conditionals RPAREN scope .)
    IF              reduce using rule 60 (if_stmt -> IF LPAREN conditionals RPAREN scope .)
    RETURN          reduce using rule 60 (if_stmt -> IF LPAREN conditionals RPAREN scope .)
    ID              reduce using rule 60 (if_stmt -> IF LPAREN conditionals RPAREN scope .)
    LPAREN          reduce using rule 60 (if_stmt -> IF LPAREN conditionals RPAREN scope .)
    GOTO            reduce using rule 60 (if_stmt -> IF LPAREN conditionals RPAREN scope .)
    BREAK           reduce using rule 60 (if_stmt -> IF LPAREN conditionals RPAREN scope .)
    INT             reduce using rule 60 (if_stmt -> IF LPAREN conditionals RPAREN scope .)
    CHAR            reduce using rule 60 (if_stmt -> IF LPAREN conditionals RPAREN scope .)
    SEMI            reduce using rule 60 (if_stmt -> IF LPAREN conditionals RPAREN scope .)
    RBRACE          reduce using rule 60 (if_stmt -> IF LPAREN conditionals RPAREN scope .)
    ELSE            shift and go to state 111

    elsiflist                      shift and go to state 110

state 110

    (61) if_stmt -> IF LPAREN conditionals RPAREN scope elsiflist .

    WHILE           reduce using rule 61 (if_stmt -> IF LPAREN conditionals RPAREN scope elsiflist .)
    IF              reduce using rule 61 (if_stmt -> IF LPAREN conditionals RPAREN scope elsiflist .)
    RETURN          reduce using rule 61 (if_stmt -> IF LPAREN conditionals RPAREN scope elsiflist .)
    ID              reduce using rule 61 (if_stmt -> IF LPAREN conditionals RPAREN scope elsiflist .)
    LPAREN          reduce using rule 61 (if_stmt -> IF LPAREN conditionals RPAREN scope elsiflist .)
    GOTO            reduce using rule 61 (if_stmt -> IF LPAREN conditionals RPAREN scope elsiflist .)
    BREAK           reduce using rule 61 (if_stmt -> IF LPAREN conditionals RPAREN scope elsiflist .)
    INT             reduce using rule 61 (if_stmt -> IF LPAREN conditionals RPAREN scope elsiflist .)
    CHAR            reduce using rule 61 (if_stmt -> IF LPAREN conditionals RPAREN scope elsiflist .)
    SEMI            reduce using rule 61 (if_stmt -> IF LPAREN conditionals RPAREN scope elsiflist .)
    RBRACE          reduce using rule 61 (if_stmt -> IF LPAREN conditionals RPAREN scope elsiflist .)


state 111

    (62) elsiflist -> ELSE . IF LPAREN conditionals RPAREN scope elsiflist
    (63) elsiflist -> ELSE . IF LPAREN conditionals RPAREN scope empty
    (64) elsiflist -> ELSE . scope
    (48) scope -> . LBRACE statement_list RBRACE

    IF              shift and go to state 112
    LBRACE          shift and go to state 15

    scope                          shift and go to state 113

state 112

    (62) elsiflist -> ELSE IF . LPAREN conditionals RPAREN scope elsiflist
    (63) elsiflist -> ELSE IF . LPAREN conditionals RPAREN scope empty

    LPAREN          shift and go to state 114


state 113

    (64) elsiflist -> ELSE scope .

    WHILE           reduce using rule 64 (elsiflist -> ELSE scope .)
    IF              reduce using rule 64 (elsiflist -> ELSE scope .)
    RETURN          reduce using rule 64 (elsiflist -> ELSE scope .)
    ID              reduce using rule 64 (elsiflist -> ELSE scope .)
    LPAREN          reduce using rule 64 (elsiflist -> ELSE scope .)
    GOTO            reduce using rule 64 (elsiflist -> ELSE scope .)
    BREAK           reduce using rule 64 (elsiflist -> ELSE scope .)
    INT             reduce using rule 64 (elsiflist -> ELSE scope .)
    CHAR            reduce using rule 64 (elsiflist -> ELSE scope .)
    SEMI            reduce using rule 64 (elsiflist -> ELSE scope .)
    RBRACE          reduce using rule 64 (elsiflist -> ELSE scope .)


state 114

    (62) elsiflist -> ELSE IF LPAREN . conditionals RPAREN scope elsiflist
    (63) elsiflist -> ELSE IF LPAREN . conditionals RPAREN scope empty
    (53) conditionals -> . operand compOps operand
    (23) operand -> . ID
    (24) operand -> . NUMCONST

    ID              shift and go to state 69
    NUMCONST        shift and go to state 47

    conditionals                   shift and go to state 115
    operand                        shift and go to state 68

state 115

    (62) elsiflist -> ELSE IF LPAREN conditionals . RPAREN scope elsiflist
    (63) elsiflist -> ELSE IF LPAREN conditionals . RPAREN scope empty

    RPAREN          shift and go to state 116


state 116

    (62) elsiflist -> ELSE IF LPAREN conditionals RPAREN . scope elsiflist
    (63) elsiflist -> ELSE IF LPAREN conditionals RPAREN . scope empty
    (48) scope -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 15

    scope                          shift and go to state 117

state 117

    (62) elsiflist -> ELSE IF LPAREN conditionals RPAREN scope . elsiflist
    (63) elsiflist -> ELSE IF LPAREN conditionals RPAREN scope . empty
    (62) elsiflist -> . ELSE IF LPAREN conditionals RPAREN scope elsiflist
    (63) elsiflist -> . ELSE IF LPAREN conditionals RPAREN scope empty
    (64) elsiflist -> . ELSE scope
    (1) empty -> .

    ELSE            shift and go to state 111
    WHILE           reduce using rule 1 (empty -> .)
    IF              reduce using rule 1 (empty -> .)
    RETURN          reduce using rule 1 (empty -> .)
    ID              reduce using rule 1 (empty -> .)
    LPAREN          reduce using rule 1 (empty -> .)
    GOTO            reduce using rule 1 (empty -> .)
    BREAK           reduce using rule 1 (empty -> .)
    INT             reduce using rule 1 (empty -> .)
    CHAR            reduce using rule 1 (empty -> .)
    SEMI            reduce using rule 1 (empty -> .)
    RBRACE          reduce using rule 1 (empty -> .)

    elsiflist                      shift and go to state 118
    empty                          shift and go to state 119

state 118

    (62) elsiflist -> ELSE IF LPAREN conditionals RPAREN scope elsiflist .

    WHILE           reduce using rule 62 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope elsiflist .)
    IF              reduce using rule 62 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope elsiflist .)
    RETURN          reduce using rule 62 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope elsiflist .)
    ID              reduce using rule 62 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope elsiflist .)
    LPAREN          reduce using rule 62 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope elsiflist .)
    GOTO            reduce using rule 62 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope elsiflist .)
    BREAK           reduce using rule 62 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope elsiflist .)
    INT             reduce using rule 62 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope elsiflist .)
    CHAR            reduce using rule 62 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope elsiflist .)
    SEMI            reduce using rule 62 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope elsiflist .)
    RBRACE          reduce using rule 62 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope elsiflist .)


state 119

    (63) elsiflist -> ELSE IF LPAREN conditionals RPAREN scope empty .

    WHILE           reduce using rule 63 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope empty .)
    IF              reduce using rule 63 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope empty .)
    RETURN          reduce using rule 63 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope empty .)
    ID              reduce using rule 63 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope empty .)
    LPAREN          reduce using rule 63 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope empty .)
    GOTO            reduce using rule 63 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope empty .)
    BREAK           reduce using rule 63 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope empty .)
    INT             reduce using rule 63 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope empty .)
    CHAR            reduce using rule 63 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope empty .)
    SEMI            reduce using rule 63 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope empty .)
    RBRACE          reduce using rule 63 (elsiflist -> ELSE IF LPAREN conditionals RPAREN scope empty .)

