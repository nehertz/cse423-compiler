Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    ARROW
    AUTO
    BREAK
    CASE
    CHARACTER
    COLON
    CONST
    CONTINUE
    DEFAULT
    DO
    DOUBLE
    DQUOT
    ELLIPSIS
    ELSE
    ENUM
    EXTERN
    FLOAT
    FOR
    GOTO
    IF
    LAND
    LANGLE
    LBRACKET
    LNOT
    LONG
    LOR
    LSHIFT
    NOT
    OR
    PERIOD
    RANGLE
    RBRACKET
    REGISTER
    RSHIFT
    SHORT
    SIGNED
    SIZEOF
    SQUOT
    STATIC
    STRUCT
    SWITCH
    TYPEDEF
    UNION
    UNSIGNED
    VOID
    VOLATILE
    XOR

Grammar

Rule 0     S' -> funcDecl
Rule 1     empty -> <empty>
Rule 2     statement_list -> empty
Rule 3     statement_list -> statement SEMI statement_list
Rule 4     statement_list -> whileLoop statement_list
Rule 5     statement -> return_stmt
Rule 6     statement -> var_decl
Rule 7     statement -> var_assign
Rule 8     statement -> empty
Rule 9     expr -> expr PLUS multiplicative_expr
Rule 10    expr -> expr MINUS multiplicative_expr
Rule 11    expr -> multiplicative_expr
Rule 12    multiplicative_expr -> multiplicative_expr TIMES unary_expr
Rule 13    multiplicative_expr -> multiplicative_expr DIVIDE unary_expr
Rule 14    multiplicative_expr -> multiplicative_expr MODULO unary_expr
Rule 15    multiplicative_expr -> unary_expr
Rule 16    unary_expr -> INCREMENT operand
Rule 17    unary_expr -> DECREMENT operand
Rule 18    unary_expr -> operand INCREMENT
Rule 19    unary_expr -> operand DECREMENT
Rule 20    operand -> ID
Rule 21    operand -> NUMCONST
Rule 22    return_stmt -> RETURN operand
Rule 23    return_stmt -> RETURN expr
Rule 24    return_stmt -> RETURN var_assign
Rule 25    var_decl -> type_spec ID
Rule 26    var_decl -> type_spec var_assign
Rule 27    var_assign -> ID EQUALS operand
Rule 28    var_assign -> ID EQUALS expr
Rule 29    var_assign -> ID EQUALS STRING
Rule 30    var_assign -> LPAREN var_assign RPAREN
Rule 31    var_assign -> ID TIMESEQUAL operand
Rule 32    var_assign -> ID DIVEQUAL operand
Rule 33    var_assign -> ID MODEQUAL operand
Rule 34    var_assign -> ID PLUSEQUAL operand
Rule 35    var_assign -> ID MINUSEQUAL operand
Rule 36    var_assign -> ID LSHIFTEQUAL operand
Rule 37    var_assign -> ID RSHIFTEQUAL operand
Rule 38    var_assign -> ID ANDEQUAL operand
Rule 39    var_assign -> ID OREQUAL operand
Rule 40    var_assign -> ID XOREQUAL operand
Rule 41    type_spec_list -> type_spec_list COMMA type_spec ID
Rule 42    type_spec_list -> type_spec ID
Rule 43    type_spec -> INT
Rule 44    type_spec -> CHAR
Rule 45    scope -> LBRACE statement_list RBRACE
Rule 46    funcDecl -> type_spec ID LPAREN args RPAREN scope
Rule 47    args -> type_spec_list
Rule 48    args -> empty
Rule 49    whileLoop -> WHILE LPAREN conditionals RPAREN scope
Rule 50    conditionals -> operand compOps operand
Rule 51    compOps -> LE
Rule 52    compOps -> GE
Rule 53    compOps -> EQ
Rule 54    compOps -> NE

Terminals, with rules where they appear

AND                  : 
ANDEQUAL             : 38
ARROW                : 
AUTO                 : 
BREAK                : 
CASE                 : 
CHAR                 : 44
CHARACTER            : 
COLON                : 
COMMA                : 41
CONST                : 
CONTINUE             : 
DECREMENT            : 17 19
DEFAULT              : 
DIVEQUAL             : 32
DIVIDE               : 13
DO                   : 
DOUBLE               : 
DQUOT                : 
ELLIPSIS             : 
ELSE                 : 
ENUM                 : 
EQ                   : 53
EQUALS               : 27 28 29
EXTERN               : 
FLOAT                : 
FOR                  : 
GE                   : 52
GOTO                 : 
ID                   : 20 25 27 28 29 31 32 33 34 35 36 37 38 39 40 41 42 46
IF                   : 
INCREMENT            : 16 18
INT                  : 43
LAND                 : 
LANGLE               : 
LBRACE               : 45
LBRACKET             : 
LE                   : 51
LNOT                 : 
LONG                 : 
LOR                  : 
LPAREN               : 30 46 49
LSHIFT               : 
LSHIFTEQUAL          : 36
MINUS                : 10
MINUSEQUAL           : 35
MODEQUAL             : 33
MODULO               : 14
NE                   : 54
NOT                  : 
NUMCONST             : 21
OR                   : 
OREQUAL              : 39
PERIOD               : 
PLUS                 : 9
PLUSEQUAL            : 34
RANGLE               : 
RBRACE               : 45
RBRACKET             : 
REGISTER             : 
RETURN               : 22 23 24
RPAREN               : 30 46 49
RSHIFT               : 
RSHIFTEQUAL          : 37
SEMI                 : 3
SHORT                : 
SIGNED               : 
SIZEOF               : 
SQUOT                : 
STATIC               : 
STRING               : 29
STRUCT               : 
SWITCH               : 
TIMES                : 12
TIMESEQUAL           : 31
TYPEDEF              : 
UNION                : 
UNSIGNED             : 
VOID                 : 
VOLATILE             : 
WHILE                : 49
XOR                  : 
XOREQUAL             : 40
error                : 

Nonterminals, with rules where they appear

args                 : 46
compOps              : 50
conditionals         : 49
empty                : 2 8 48
expr                 : 9 10 23 28
funcDecl             : 0
multiplicative_expr  : 9 10 11 12 13 14
operand              : 16 17 18 19 22 27 31 32 33 34 35 36 37 38 39 40 50 50
return_stmt          : 5
scope                : 46 49
statement            : 3
statement_list       : 3 4 45
type_spec            : 25 26 41 42 46
type_spec_list       : 41 47
unary_expr           : 12 13 14 15
var_assign           : 7 24 26 30
var_decl             : 6
whileLoop            : 4

Parsing method: LALR

state 0

    (0) S' -> . funcDecl
    (46) funcDecl -> . type_spec ID LPAREN args RPAREN scope
    (43) type_spec -> . INT
    (44) type_spec -> . CHAR

    INT             shift and go to state 3
    CHAR            shift and go to state 4

    funcDecl                       shift and go to state 1
    type_spec                      shift and go to state 2

state 1

    (0) S' -> funcDecl .



state 2

    (46) funcDecl -> type_spec . ID LPAREN args RPAREN scope

    ID              shift and go to state 5


state 3

    (43) type_spec -> INT .

    ID              reduce using rule 43 (type_spec -> INT .)
    LPAREN          reduce using rule 43 (type_spec -> INT .)


state 4

    (44) type_spec -> CHAR .

    ID              reduce using rule 44 (type_spec -> CHAR .)
    LPAREN          reduce using rule 44 (type_spec -> CHAR .)


state 5

    (46) funcDecl -> type_spec ID . LPAREN args RPAREN scope

    LPAREN          shift and go to state 6


state 6

    (46) funcDecl -> type_spec ID LPAREN . args RPAREN scope
    (47) args -> . type_spec_list
    (48) args -> . empty
    (41) type_spec_list -> . type_spec_list COMMA type_spec ID
    (42) type_spec_list -> . type_spec ID
    (1) empty -> .
    (43) type_spec -> . INT
    (44) type_spec -> . CHAR

    RPAREN          reduce using rule 1 (empty -> .)
    INT             shift and go to state 3
    CHAR            shift and go to state 4

    type_spec                      shift and go to state 7
    args                           shift and go to state 8
    type_spec_list                 shift and go to state 9
    empty                          shift and go to state 10

state 7

    (42) type_spec_list -> type_spec . ID

    ID              shift and go to state 11


state 8

    (46) funcDecl -> type_spec ID LPAREN args . RPAREN scope

    RPAREN          shift and go to state 12


state 9

    (47) args -> type_spec_list .
    (41) type_spec_list -> type_spec_list . COMMA type_spec ID

    RPAREN          reduce using rule 47 (args -> type_spec_list .)
    COMMA           shift and go to state 13


state 10

    (48) args -> empty .

    RPAREN          reduce using rule 48 (args -> empty .)


state 11

    (42) type_spec_list -> type_spec ID .

    COMMA           reduce using rule 42 (type_spec_list -> type_spec ID .)
    RPAREN          reduce using rule 42 (type_spec_list -> type_spec ID .)


state 12

    (46) funcDecl -> type_spec ID LPAREN args RPAREN . scope
    (45) scope -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 15

    scope                          shift and go to state 14

state 13

    (41) type_spec_list -> type_spec_list COMMA . type_spec ID
    (43) type_spec -> . INT
    (44) type_spec -> . CHAR

    INT             shift and go to state 3
    CHAR            shift and go to state 4

    type_spec                      shift and go to state 16

state 14

    (46) funcDecl -> type_spec ID LPAREN args RPAREN scope .

    $end            reduce using rule 46 (funcDecl -> type_spec ID LPAREN args RPAREN scope .)


state 15

    (45) scope -> LBRACE . statement_list RBRACE
    (2) statement_list -> . empty
    (3) statement_list -> . statement SEMI statement_list
    (4) statement_list -> . whileLoop statement_list
    (1) empty -> .
    (5) statement -> . return_stmt
    (6) statement -> . var_decl
    (7) statement -> . var_assign
    (8) statement -> . empty
    (49) whileLoop -> . WHILE LPAREN conditionals RPAREN scope
    (22) return_stmt -> . RETURN operand
    (23) return_stmt -> . RETURN expr
    (24) return_stmt -> . RETURN var_assign
    (25) var_decl -> . type_spec ID
    (26) var_decl -> . type_spec var_assign
    (27) var_assign -> . ID EQUALS operand
    (28) var_assign -> . ID EQUALS expr
    (29) var_assign -> . ID EQUALS STRING
    (30) var_assign -> . LPAREN var_assign RPAREN
    (31) var_assign -> . ID TIMESEQUAL operand
    (32) var_assign -> . ID DIVEQUAL operand
    (33) var_assign -> . ID MODEQUAL operand
    (34) var_assign -> . ID PLUSEQUAL operand
    (35) var_assign -> . ID MINUSEQUAL operand
    (36) var_assign -> . ID LSHIFTEQUAL operand
    (37) var_assign -> . ID RSHIFTEQUAL operand
    (38) var_assign -> . ID ANDEQUAL operand
    (39) var_assign -> . ID OREQUAL operand
    (40) var_assign -> . ID XOREQUAL operand
    (43) type_spec -> . INT
    (44) type_spec -> . CHAR

    RBRACE          reduce using rule 1 (empty -> .)
    SEMI            reduce using rule 1 (empty -> .)
    WHILE           shift and go to state 24
    RETURN          shift and go to state 26
    ID              shift and go to state 28
    LPAREN          shift and go to state 25
    INT             shift and go to state 3
    CHAR            shift and go to state 4

    statement_list                 shift and go to state 17
    empty                          shift and go to state 18
    statement                      shift and go to state 19
    whileLoop                      shift and go to state 20
    return_stmt                    shift and go to state 21
    var_decl                       shift and go to state 22
    var_assign                     shift and go to state 23
    type_spec                      shift and go to state 27

state 16

    (41) type_spec_list -> type_spec_list COMMA type_spec . ID

    ID              shift and go to state 29


state 17

    (45) scope -> LBRACE statement_list . RBRACE

    RBRACE          shift and go to state 30


state 18

    (2) statement_list -> empty .
    (8) statement -> empty .

    RBRACE          reduce using rule 2 (statement_list -> empty .)
    SEMI            reduce using rule 8 (statement -> empty .)


state 19

    (3) statement_list -> statement . SEMI statement_list

    SEMI            shift and go to state 31


state 20

    (4) statement_list -> whileLoop . statement_list
    (2) statement_list -> . empty
    (3) statement_list -> . statement SEMI statement_list
    (4) statement_list -> . whileLoop statement_list
    (1) empty -> .
    (5) statement -> . return_stmt
    (6) statement -> . var_decl
    (7) statement -> . var_assign
    (8) statement -> . empty
    (49) whileLoop -> . WHILE LPAREN conditionals RPAREN scope
    (22) return_stmt -> . RETURN operand
    (23) return_stmt -> . RETURN expr
    (24) return_stmt -> . RETURN var_assign
    (25) var_decl -> . type_spec ID
    (26) var_decl -> . type_spec var_assign
    (27) var_assign -> . ID EQUALS operand
    (28) var_assign -> . ID EQUALS expr
    (29) var_assign -> . ID EQUALS STRING
    (30) var_assign -> . LPAREN var_assign RPAREN
    (31) var_assign -> . ID TIMESEQUAL operand
    (32) var_assign -> . ID DIVEQUAL operand
    (33) var_assign -> . ID MODEQUAL operand
    (34) var_assign -> . ID PLUSEQUAL operand
    (35) var_assign -> . ID MINUSEQUAL operand
    (36) var_assign -> . ID LSHIFTEQUAL operand
    (37) var_assign -> . ID RSHIFTEQUAL operand
    (38) var_assign -> . ID ANDEQUAL operand
    (39) var_assign -> . ID OREQUAL operand
    (40) var_assign -> . ID XOREQUAL operand
    (43) type_spec -> . INT
    (44) type_spec -> . CHAR

    RBRACE          reduce using rule 1 (empty -> .)
    SEMI            reduce using rule 1 (empty -> .)
    WHILE           shift and go to state 24
    RETURN          shift and go to state 26
    ID              shift and go to state 28
    LPAREN          shift and go to state 25
    INT             shift and go to state 3
    CHAR            shift and go to state 4

    whileLoop                      shift and go to state 20
    statement_list                 shift and go to state 32
    empty                          shift and go to state 18
    statement                      shift and go to state 19
    return_stmt                    shift and go to state 21
    var_decl                       shift and go to state 22
    var_assign                     shift and go to state 23
    type_spec                      shift and go to state 27

state 21

    (5) statement -> return_stmt .

    SEMI            reduce using rule 5 (statement -> return_stmt .)


state 22

    (6) statement -> var_decl .

    SEMI            reduce using rule 6 (statement -> var_decl .)


state 23

    (7) statement -> var_assign .

    SEMI            reduce using rule 7 (statement -> var_assign .)


state 24

    (49) whileLoop -> WHILE . LPAREN conditionals RPAREN scope

    LPAREN          shift and go to state 33


state 25

    (30) var_assign -> LPAREN . var_assign RPAREN
    (27) var_assign -> . ID EQUALS operand
    (28) var_assign -> . ID EQUALS expr
    (29) var_assign -> . ID EQUALS STRING
    (30) var_assign -> . LPAREN var_assign RPAREN
    (31) var_assign -> . ID TIMESEQUAL operand
    (32) var_assign -> . ID DIVEQUAL operand
    (33) var_assign -> . ID MODEQUAL operand
    (34) var_assign -> . ID PLUSEQUAL operand
    (35) var_assign -> . ID MINUSEQUAL operand
    (36) var_assign -> . ID LSHIFTEQUAL operand
    (37) var_assign -> . ID RSHIFTEQUAL operand
    (38) var_assign -> . ID ANDEQUAL operand
    (39) var_assign -> . ID OREQUAL operand
    (40) var_assign -> . ID XOREQUAL operand

    ID              shift and go to state 28
    LPAREN          shift and go to state 25

    var_assign                     shift and go to state 34

state 26

    (22) return_stmt -> RETURN . operand
    (23) return_stmt -> RETURN . expr
    (24) return_stmt -> RETURN . var_assign
    (20) operand -> . ID
    (21) operand -> . NUMCONST
    (9) expr -> . expr PLUS multiplicative_expr
    (10) expr -> . expr MINUS multiplicative_expr
    (11) expr -> . multiplicative_expr
    (27) var_assign -> . ID EQUALS operand
    (28) var_assign -> . ID EQUALS expr
    (29) var_assign -> . ID EQUALS STRING
    (30) var_assign -> . LPAREN var_assign RPAREN
    (31) var_assign -> . ID TIMESEQUAL operand
    (32) var_assign -> . ID DIVEQUAL operand
    (33) var_assign -> . ID MODEQUAL operand
    (34) var_assign -> . ID PLUSEQUAL operand
    (35) var_assign -> . ID MINUSEQUAL operand
    (36) var_assign -> . ID LSHIFTEQUAL operand
    (37) var_assign -> . ID RSHIFTEQUAL operand
    (38) var_assign -> . ID ANDEQUAL operand
    (39) var_assign -> . ID OREQUAL operand
    (40) var_assign -> . ID XOREQUAL operand
    (12) multiplicative_expr -> . multiplicative_expr TIMES unary_expr
    (13) multiplicative_expr -> . multiplicative_expr DIVIDE unary_expr
    (14) multiplicative_expr -> . multiplicative_expr MODULO unary_expr
    (15) multiplicative_expr -> . unary_expr
    (16) unary_expr -> . INCREMENT operand
    (17) unary_expr -> . DECREMENT operand
    (18) unary_expr -> . operand INCREMENT
    (19) unary_expr -> . operand DECREMENT

    ID              shift and go to state 38
    NUMCONST        shift and go to state 39
    LPAREN          shift and go to state 25
    INCREMENT       shift and go to state 42
    DECREMENT       shift and go to state 43

    operand                        shift and go to state 35
    expr                           shift and go to state 36
    var_assign                     shift and go to state 37
    multiplicative_expr            shift and go to state 40
    unary_expr                     shift and go to state 41

state 27

    (25) var_decl -> type_spec . ID
    (26) var_decl -> type_spec . var_assign
    (27) var_assign -> . ID EQUALS operand
    (28) var_assign -> . ID EQUALS expr
    (29) var_assign -> . ID EQUALS STRING
    (30) var_assign -> . LPAREN var_assign RPAREN
    (31) var_assign -> . ID TIMESEQUAL operand
    (32) var_assign -> . ID DIVEQUAL operand
    (33) var_assign -> . ID MODEQUAL operand
    (34) var_assign -> . ID PLUSEQUAL operand
    (35) var_assign -> . ID MINUSEQUAL operand
    (36) var_assign -> . ID LSHIFTEQUAL operand
    (37) var_assign -> . ID RSHIFTEQUAL operand
    (38) var_assign -> . ID ANDEQUAL operand
    (39) var_assign -> . ID OREQUAL operand
    (40) var_assign -> . ID XOREQUAL operand

    ID              shift and go to state 44
    LPAREN          shift and go to state 25

    var_assign                     shift and go to state 45

state 28

    (27) var_assign -> ID . EQUALS operand
    (28) var_assign -> ID . EQUALS expr
    (29) var_assign -> ID . EQUALS STRING
    (31) var_assign -> ID . TIMESEQUAL operand
    (32) var_assign -> ID . DIVEQUAL operand
    (33) var_assign -> ID . MODEQUAL operand
    (34) var_assign -> ID . PLUSEQUAL operand
    (35) var_assign -> ID . MINUSEQUAL operand
    (36) var_assign -> ID . LSHIFTEQUAL operand
    (37) var_assign -> ID . RSHIFTEQUAL operand
    (38) var_assign -> ID . ANDEQUAL operand
    (39) var_assign -> ID . OREQUAL operand
    (40) var_assign -> ID . XOREQUAL operand

    EQUALS          shift and go to state 46
    TIMESEQUAL      shift and go to state 47
    DIVEQUAL        shift and go to state 48
    MODEQUAL        shift and go to state 49
    PLUSEQUAL       shift and go to state 50
    MINUSEQUAL      shift and go to state 51
    LSHIFTEQUAL     shift and go to state 52
    RSHIFTEQUAL     shift and go to state 53
    ANDEQUAL        shift and go to state 54
    OREQUAL         shift and go to state 55
    XOREQUAL        shift and go to state 56


state 29

    (41) type_spec_list -> type_spec_list COMMA type_spec ID .

    COMMA           reduce using rule 41 (type_spec_list -> type_spec_list COMMA type_spec ID .)
    RPAREN          reduce using rule 41 (type_spec_list -> type_spec_list COMMA type_spec ID .)


state 30

    (45) scope -> LBRACE statement_list RBRACE .

    $end            reduce using rule 45 (scope -> LBRACE statement_list RBRACE .)
    WHILE           reduce using rule 45 (scope -> LBRACE statement_list RBRACE .)
    RETURN          reduce using rule 45 (scope -> LBRACE statement_list RBRACE .)
    ID              reduce using rule 45 (scope -> LBRACE statement_list RBRACE .)
    LPAREN          reduce using rule 45 (scope -> LBRACE statement_list RBRACE .)
    INT             reduce using rule 45 (scope -> LBRACE statement_list RBRACE .)
    CHAR            reduce using rule 45 (scope -> LBRACE statement_list RBRACE .)
    SEMI            reduce using rule 45 (scope -> LBRACE statement_list RBRACE .)
    RBRACE          reduce using rule 45 (scope -> LBRACE statement_list RBRACE .)


state 31

    (3) statement_list -> statement SEMI . statement_list
    (2) statement_list -> . empty
    (3) statement_list -> . statement SEMI statement_list
    (4) statement_list -> . whileLoop statement_list
    (1) empty -> .
    (5) statement -> . return_stmt
    (6) statement -> . var_decl
    (7) statement -> . var_assign
    (8) statement -> . empty
    (49) whileLoop -> . WHILE LPAREN conditionals RPAREN scope
    (22) return_stmt -> . RETURN operand
    (23) return_stmt -> . RETURN expr
    (24) return_stmt -> . RETURN var_assign
    (25) var_decl -> . type_spec ID
    (26) var_decl -> . type_spec var_assign
    (27) var_assign -> . ID EQUALS operand
    (28) var_assign -> . ID EQUALS expr
    (29) var_assign -> . ID EQUALS STRING
    (30) var_assign -> . LPAREN var_assign RPAREN
    (31) var_assign -> . ID TIMESEQUAL operand
    (32) var_assign -> . ID DIVEQUAL operand
    (33) var_assign -> . ID MODEQUAL operand
    (34) var_assign -> . ID PLUSEQUAL operand
    (35) var_assign -> . ID MINUSEQUAL operand
    (36) var_assign -> . ID LSHIFTEQUAL operand
    (37) var_assign -> . ID RSHIFTEQUAL operand
    (38) var_assign -> . ID ANDEQUAL operand
    (39) var_assign -> . ID OREQUAL operand
    (40) var_assign -> . ID XOREQUAL operand
    (43) type_spec -> . INT
    (44) type_spec -> . CHAR

    RBRACE          reduce using rule 1 (empty -> .)
    SEMI            reduce using rule 1 (empty -> .)
    WHILE           shift and go to state 24
    RETURN          shift and go to state 26
    ID              shift and go to state 28
    LPAREN          shift and go to state 25
    INT             shift and go to state 3
    CHAR            shift and go to state 4

    statement                      shift and go to state 19
    statement_list                 shift and go to state 57
    empty                          shift and go to state 18
    whileLoop                      shift and go to state 20
    return_stmt                    shift and go to state 21
    var_decl                       shift and go to state 22
    var_assign                     shift and go to state 23
    type_spec                      shift and go to state 27

state 32

    (4) statement_list -> whileLoop statement_list .

    RBRACE          reduce using rule 4 (statement_list -> whileLoop statement_list .)


state 33

    (49) whileLoop -> WHILE LPAREN . conditionals RPAREN scope
    (50) conditionals -> . operand compOps operand
    (20) operand -> . ID
    (21) operand -> . NUMCONST

    ID              shift and go to state 60
    NUMCONST        shift and go to state 39

    conditionals                   shift and go to state 58
    operand                        shift and go to state 59

state 34

    (30) var_assign -> LPAREN var_assign . RPAREN

    RPAREN          shift and go to state 61


state 35

    (22) return_stmt -> RETURN operand .
    (18) unary_expr -> operand . INCREMENT
    (19) unary_expr -> operand . DECREMENT

    SEMI            reduce using rule 22 (return_stmt -> RETURN operand .)
    INCREMENT       shift and go to state 62
    DECREMENT       shift and go to state 63


state 36

    (23) return_stmt -> RETURN expr .
    (9) expr -> expr . PLUS multiplicative_expr
    (10) expr -> expr . MINUS multiplicative_expr

    SEMI            reduce using rule 23 (return_stmt -> RETURN expr .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65


state 37

    (24) return_stmt -> RETURN var_assign .

    SEMI            reduce using rule 24 (return_stmt -> RETURN var_assign .)


state 38

    (20) operand -> ID .
    (27) var_assign -> ID . EQUALS operand
    (28) var_assign -> ID . EQUALS expr
    (29) var_assign -> ID . EQUALS STRING
    (31) var_assign -> ID . TIMESEQUAL operand
    (32) var_assign -> ID . DIVEQUAL operand
    (33) var_assign -> ID . MODEQUAL operand
    (34) var_assign -> ID . PLUSEQUAL operand
    (35) var_assign -> ID . MINUSEQUAL operand
    (36) var_assign -> ID . LSHIFTEQUAL operand
    (37) var_assign -> ID . RSHIFTEQUAL operand
    (38) var_assign -> ID . ANDEQUAL operand
    (39) var_assign -> ID . OREQUAL operand
    (40) var_assign -> ID . XOREQUAL operand

    INCREMENT       reduce using rule 20 (operand -> ID .)
    DECREMENT       reduce using rule 20 (operand -> ID .)
    SEMI            reduce using rule 20 (operand -> ID .)
    EQUALS          shift and go to state 46
    TIMESEQUAL      shift and go to state 47
    DIVEQUAL        shift and go to state 48
    MODEQUAL        shift and go to state 49
    PLUSEQUAL       shift and go to state 50
    MINUSEQUAL      shift and go to state 51
    LSHIFTEQUAL     shift and go to state 52
    RSHIFTEQUAL     shift and go to state 53
    ANDEQUAL        shift and go to state 54
    OREQUAL         shift and go to state 55
    XOREQUAL        shift and go to state 56


state 39

    (21) operand -> NUMCONST .

    INCREMENT       reduce using rule 21 (operand -> NUMCONST .)
    DECREMENT       reduce using rule 21 (operand -> NUMCONST .)
    SEMI            reduce using rule 21 (operand -> NUMCONST .)
    LE              reduce using rule 21 (operand -> NUMCONST .)
    GE              reduce using rule 21 (operand -> NUMCONST .)
    EQ              reduce using rule 21 (operand -> NUMCONST .)
    NE              reduce using rule 21 (operand -> NUMCONST .)
    TIMES           reduce using rule 21 (operand -> NUMCONST .)
    DIVIDE          reduce using rule 21 (operand -> NUMCONST .)
    MODULO          reduce using rule 21 (operand -> NUMCONST .)
    PLUS            reduce using rule 21 (operand -> NUMCONST .)
    MINUS           reduce using rule 21 (operand -> NUMCONST .)
    RPAREN          reduce using rule 21 (operand -> NUMCONST .)


state 40

    (11) expr -> multiplicative_expr .
    (12) multiplicative_expr -> multiplicative_expr . TIMES unary_expr
    (13) multiplicative_expr -> multiplicative_expr . DIVIDE unary_expr
    (14) multiplicative_expr -> multiplicative_expr . MODULO unary_expr

    PLUS            reduce using rule 11 (expr -> multiplicative_expr .)
    MINUS           reduce using rule 11 (expr -> multiplicative_expr .)
    SEMI            reduce using rule 11 (expr -> multiplicative_expr .)
    RPAREN          reduce using rule 11 (expr -> multiplicative_expr .)
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MODULO          shift and go to state 68


state 41

    (15) multiplicative_expr -> unary_expr .

    TIMES           reduce using rule 15 (multiplicative_expr -> unary_expr .)
    DIVIDE          reduce using rule 15 (multiplicative_expr -> unary_expr .)
    MODULO          reduce using rule 15 (multiplicative_expr -> unary_expr .)
    PLUS            reduce using rule 15 (multiplicative_expr -> unary_expr .)
    MINUS           reduce using rule 15 (multiplicative_expr -> unary_expr .)
    SEMI            reduce using rule 15 (multiplicative_expr -> unary_expr .)
    RPAREN          reduce using rule 15 (multiplicative_expr -> unary_expr .)


state 42

    (16) unary_expr -> INCREMENT . operand
    (20) operand -> . ID
    (21) operand -> . NUMCONST

    ID              shift and go to state 60
    NUMCONST        shift and go to state 39

    operand                        shift and go to state 69

state 43

    (17) unary_expr -> DECREMENT . operand
    (20) operand -> . ID
    (21) operand -> . NUMCONST

    ID              shift and go to state 60
    NUMCONST        shift and go to state 39

    operand                        shift and go to state 70

state 44

    (25) var_decl -> type_spec ID .
    (27) var_assign -> ID . EQUALS operand
    (28) var_assign -> ID . EQUALS expr
    (29) var_assign -> ID . EQUALS STRING
    (31) var_assign -> ID . TIMESEQUAL operand
    (32) var_assign -> ID . DIVEQUAL operand
    (33) var_assign -> ID . MODEQUAL operand
    (34) var_assign -> ID . PLUSEQUAL operand
    (35) var_assign -> ID . MINUSEQUAL operand
    (36) var_assign -> ID . LSHIFTEQUAL operand
    (37) var_assign -> ID . RSHIFTEQUAL operand
    (38) var_assign -> ID . ANDEQUAL operand
    (39) var_assign -> ID . OREQUAL operand
    (40) var_assign -> ID . XOREQUAL operand

    SEMI            reduce using rule 25 (var_decl -> type_spec ID .)
    EQUALS          shift and go to state 46
    TIMESEQUAL      shift and go to state 47
    DIVEQUAL        shift and go to state 48
    MODEQUAL        shift and go to state 49
    PLUSEQUAL       shift and go to state 50
    MINUSEQUAL      shift and go to state 51
    LSHIFTEQUAL     shift and go to state 52
    RSHIFTEQUAL     shift and go to state 53
    ANDEQUAL        shift and go to state 54
    OREQUAL         shift and go to state 55
    XOREQUAL        shift and go to state 56


state 45

    (26) var_decl -> type_spec var_assign .

    SEMI            reduce using rule 26 (var_decl -> type_spec var_assign .)


state 46

    (27) var_assign -> ID EQUALS . operand
    (28) var_assign -> ID EQUALS . expr
    (29) var_assign -> ID EQUALS . STRING
    (20) operand -> . ID
    (21) operand -> . NUMCONST
    (9) expr -> . expr PLUS multiplicative_expr
    (10) expr -> . expr MINUS multiplicative_expr
    (11) expr -> . multiplicative_expr
    (12) multiplicative_expr -> . multiplicative_expr TIMES unary_expr
    (13) multiplicative_expr -> . multiplicative_expr DIVIDE unary_expr
    (14) multiplicative_expr -> . multiplicative_expr MODULO unary_expr
    (15) multiplicative_expr -> . unary_expr
    (16) unary_expr -> . INCREMENT operand
    (17) unary_expr -> . DECREMENT operand
    (18) unary_expr -> . operand INCREMENT
    (19) unary_expr -> . operand DECREMENT

    STRING          shift and go to state 73
    ID              shift and go to state 60
    NUMCONST        shift and go to state 39
    INCREMENT       shift and go to state 42
    DECREMENT       shift and go to state 43

    operand                        shift and go to state 71
    expr                           shift and go to state 72
    multiplicative_expr            shift and go to state 40
    unary_expr                     shift and go to state 41

state 47

    (31) var_assign -> ID TIMESEQUAL . operand
    (20) operand -> . ID
    (21) operand -> . NUMCONST

    ID              shift and go to state 60
    NUMCONST        shift and go to state 39

    operand                        shift and go to state 74

state 48

    (32) var_assign -> ID DIVEQUAL . operand
    (20) operand -> . ID
    (21) operand -> . NUMCONST

    ID              shift and go to state 60
    NUMCONST        shift and go to state 39

    operand                        shift and go to state 75

state 49

    (33) var_assign -> ID MODEQUAL . operand
    (20) operand -> . ID
    (21) operand -> . NUMCONST

    ID              shift and go to state 60
    NUMCONST        shift and go to state 39

    operand                        shift and go to state 76

state 50

    (34) var_assign -> ID PLUSEQUAL . operand
    (20) operand -> . ID
    (21) operand -> . NUMCONST

    ID              shift and go to state 60
    NUMCONST        shift and go to state 39

    operand                        shift and go to state 77

state 51

    (35) var_assign -> ID MINUSEQUAL . operand
    (20) operand -> . ID
    (21) operand -> . NUMCONST

    ID              shift and go to state 60
    NUMCONST        shift and go to state 39

    operand                        shift and go to state 78

state 52

    (36) var_assign -> ID LSHIFTEQUAL . operand
    (20) operand -> . ID
    (21) operand -> . NUMCONST

    ID              shift and go to state 60
    NUMCONST        shift and go to state 39

    operand                        shift and go to state 79

state 53

    (37) var_assign -> ID RSHIFTEQUAL . operand
    (20) operand -> . ID
    (21) operand -> . NUMCONST

    ID              shift and go to state 60
    NUMCONST        shift and go to state 39

    operand                        shift and go to state 80

state 54

    (38) var_assign -> ID ANDEQUAL . operand
    (20) operand -> . ID
    (21) operand -> . NUMCONST

    ID              shift and go to state 60
    NUMCONST        shift and go to state 39

    operand                        shift and go to state 81

state 55

    (39) var_assign -> ID OREQUAL . operand
    (20) operand -> . ID
    (21) operand -> . NUMCONST

    ID              shift and go to state 60
    NUMCONST        shift and go to state 39

    operand                        shift and go to state 82

state 56

    (40) var_assign -> ID XOREQUAL . operand
    (20) operand -> . ID
    (21) operand -> . NUMCONST

    ID              shift and go to state 60
    NUMCONST        shift and go to state 39

    operand                        shift and go to state 83

state 57

    (3) statement_list -> statement SEMI statement_list .

    RBRACE          reduce using rule 3 (statement_list -> statement SEMI statement_list .)


state 58

    (49) whileLoop -> WHILE LPAREN conditionals . RPAREN scope

    RPAREN          shift and go to state 84


state 59

    (50) conditionals -> operand . compOps operand
    (51) compOps -> . LE
    (52) compOps -> . GE
    (53) compOps -> . EQ
    (54) compOps -> . NE

    LE              shift and go to state 86
    GE              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89

    compOps                        shift and go to state 85

state 60

    (20) operand -> ID .

    LE              reduce using rule 20 (operand -> ID .)
    GE              reduce using rule 20 (operand -> ID .)
    EQ              reduce using rule 20 (operand -> ID .)
    NE              reduce using rule 20 (operand -> ID .)
    TIMES           reduce using rule 20 (operand -> ID .)
    DIVIDE          reduce using rule 20 (operand -> ID .)
    MODULO          reduce using rule 20 (operand -> ID .)
    PLUS            reduce using rule 20 (operand -> ID .)
    MINUS           reduce using rule 20 (operand -> ID .)
    SEMI            reduce using rule 20 (operand -> ID .)
    RPAREN          reduce using rule 20 (operand -> ID .)
    INCREMENT       reduce using rule 20 (operand -> ID .)
    DECREMENT       reduce using rule 20 (operand -> ID .)


state 61

    (30) var_assign -> LPAREN var_assign RPAREN .

    SEMI            reduce using rule 30 (var_assign -> LPAREN var_assign RPAREN .)
    RPAREN          reduce using rule 30 (var_assign -> LPAREN var_assign RPAREN .)


state 62

    (18) unary_expr -> operand INCREMENT .

    TIMES           reduce using rule 18 (unary_expr -> operand INCREMENT .)
    DIVIDE          reduce using rule 18 (unary_expr -> operand INCREMENT .)
    MODULO          reduce using rule 18 (unary_expr -> operand INCREMENT .)
    PLUS            reduce using rule 18 (unary_expr -> operand INCREMENT .)
    MINUS           reduce using rule 18 (unary_expr -> operand INCREMENT .)
    SEMI            reduce using rule 18 (unary_expr -> operand INCREMENT .)
    RPAREN          reduce using rule 18 (unary_expr -> operand INCREMENT .)


state 63

    (19) unary_expr -> operand DECREMENT .

    TIMES           reduce using rule 19 (unary_expr -> operand DECREMENT .)
    DIVIDE          reduce using rule 19 (unary_expr -> operand DECREMENT .)
    MODULO          reduce using rule 19 (unary_expr -> operand DECREMENT .)
    PLUS            reduce using rule 19 (unary_expr -> operand DECREMENT .)
    MINUS           reduce using rule 19 (unary_expr -> operand DECREMENT .)
    SEMI            reduce using rule 19 (unary_expr -> operand DECREMENT .)
    RPAREN          reduce using rule 19 (unary_expr -> operand DECREMENT .)


state 64

    (9) expr -> expr PLUS . multiplicative_expr
    (12) multiplicative_expr -> . multiplicative_expr TIMES unary_expr
    (13) multiplicative_expr -> . multiplicative_expr DIVIDE unary_expr
    (14) multiplicative_expr -> . multiplicative_expr MODULO unary_expr
    (15) multiplicative_expr -> . unary_expr
    (16) unary_expr -> . INCREMENT operand
    (17) unary_expr -> . DECREMENT operand
    (18) unary_expr -> . operand INCREMENT
    (19) unary_expr -> . operand DECREMENT
    (20) operand -> . ID
    (21) operand -> . NUMCONST

    INCREMENT       shift and go to state 42
    DECREMENT       shift and go to state 43
    ID              shift and go to state 60
    NUMCONST        shift and go to state 39

    multiplicative_expr            shift and go to state 90
    unary_expr                     shift and go to state 41
    operand                        shift and go to state 91

state 65

    (10) expr -> expr MINUS . multiplicative_expr
    (12) multiplicative_expr -> . multiplicative_expr TIMES unary_expr
    (13) multiplicative_expr -> . multiplicative_expr DIVIDE unary_expr
    (14) multiplicative_expr -> . multiplicative_expr MODULO unary_expr
    (15) multiplicative_expr -> . unary_expr
    (16) unary_expr -> . INCREMENT operand
    (17) unary_expr -> . DECREMENT operand
    (18) unary_expr -> . operand INCREMENT
    (19) unary_expr -> . operand DECREMENT
    (20) operand -> . ID
    (21) operand -> . NUMCONST

    INCREMENT       shift and go to state 42
    DECREMENT       shift and go to state 43
    ID              shift and go to state 60
    NUMCONST        shift and go to state 39

    multiplicative_expr            shift and go to state 92
    unary_expr                     shift and go to state 41
    operand                        shift and go to state 91

state 66

    (12) multiplicative_expr -> multiplicative_expr TIMES . unary_expr
    (16) unary_expr -> . INCREMENT operand
    (17) unary_expr -> . DECREMENT operand
    (18) unary_expr -> . operand INCREMENT
    (19) unary_expr -> . operand DECREMENT
    (20) operand -> . ID
    (21) operand -> . NUMCONST

    INCREMENT       shift and go to state 42
    DECREMENT       shift and go to state 43
    ID              shift and go to state 60
    NUMCONST        shift and go to state 39

    unary_expr                     shift and go to state 93
    operand                        shift and go to state 91

state 67

    (13) multiplicative_expr -> multiplicative_expr DIVIDE . unary_expr
    (16) unary_expr -> . INCREMENT operand
    (17) unary_expr -> . DECREMENT operand
    (18) unary_expr -> . operand INCREMENT
    (19) unary_expr -> . operand DECREMENT
    (20) operand -> . ID
    (21) operand -> . NUMCONST

    INCREMENT       shift and go to state 42
    DECREMENT       shift and go to state 43
    ID              shift and go to state 60
    NUMCONST        shift and go to state 39

    unary_expr                     shift and go to state 94
    operand                        shift and go to state 91

state 68

    (14) multiplicative_expr -> multiplicative_expr MODULO . unary_expr
    (16) unary_expr -> . INCREMENT operand
    (17) unary_expr -> . DECREMENT operand
    (18) unary_expr -> . operand INCREMENT
    (19) unary_expr -> . operand DECREMENT
    (20) operand -> . ID
    (21) operand -> . NUMCONST

    INCREMENT       shift and go to state 42
    DECREMENT       shift and go to state 43
    ID              shift and go to state 60
    NUMCONST        shift and go to state 39

    unary_expr                     shift and go to state 95
    operand                        shift and go to state 91

state 69

    (16) unary_expr -> INCREMENT operand .

    TIMES           reduce using rule 16 (unary_expr -> INCREMENT operand .)
    DIVIDE          reduce using rule 16 (unary_expr -> INCREMENT operand .)
    MODULO          reduce using rule 16 (unary_expr -> INCREMENT operand .)
    PLUS            reduce using rule 16 (unary_expr -> INCREMENT operand .)
    MINUS           reduce using rule 16 (unary_expr -> INCREMENT operand .)
    SEMI            reduce using rule 16 (unary_expr -> INCREMENT operand .)
    RPAREN          reduce using rule 16 (unary_expr -> INCREMENT operand .)


state 70

    (17) unary_expr -> DECREMENT operand .

    TIMES           reduce using rule 17 (unary_expr -> DECREMENT operand .)
    DIVIDE          reduce using rule 17 (unary_expr -> DECREMENT operand .)
    MODULO          reduce using rule 17 (unary_expr -> DECREMENT operand .)
    PLUS            reduce using rule 17 (unary_expr -> DECREMENT operand .)
    MINUS           reduce using rule 17 (unary_expr -> DECREMENT operand .)
    SEMI            reduce using rule 17 (unary_expr -> DECREMENT operand .)
    RPAREN          reduce using rule 17 (unary_expr -> DECREMENT operand .)


state 71

    (27) var_assign -> ID EQUALS operand .
    (18) unary_expr -> operand . INCREMENT
    (19) unary_expr -> operand . DECREMENT

    SEMI            reduce using rule 27 (var_assign -> ID EQUALS operand .)
    RPAREN          reduce using rule 27 (var_assign -> ID EQUALS operand .)
    INCREMENT       shift and go to state 62
    DECREMENT       shift and go to state 63


state 72

    (28) var_assign -> ID EQUALS expr .
    (9) expr -> expr . PLUS multiplicative_expr
    (10) expr -> expr . MINUS multiplicative_expr

    SEMI            reduce using rule 28 (var_assign -> ID EQUALS expr .)
    RPAREN          reduce using rule 28 (var_assign -> ID EQUALS expr .)
    PLUS            shift and go to state 64
    MINUS           shift and go to state 65


state 73

    (29) var_assign -> ID EQUALS STRING .

    SEMI            reduce using rule 29 (var_assign -> ID EQUALS STRING .)
    RPAREN          reduce using rule 29 (var_assign -> ID EQUALS STRING .)


state 74

    (31) var_assign -> ID TIMESEQUAL operand .

    SEMI            reduce using rule 31 (var_assign -> ID TIMESEQUAL operand .)
    RPAREN          reduce using rule 31 (var_assign -> ID TIMESEQUAL operand .)


state 75

    (32) var_assign -> ID DIVEQUAL operand .

    SEMI            reduce using rule 32 (var_assign -> ID DIVEQUAL operand .)
    RPAREN          reduce using rule 32 (var_assign -> ID DIVEQUAL operand .)


state 76

    (33) var_assign -> ID MODEQUAL operand .

    SEMI            reduce using rule 33 (var_assign -> ID MODEQUAL operand .)
    RPAREN          reduce using rule 33 (var_assign -> ID MODEQUAL operand .)


state 77

    (34) var_assign -> ID PLUSEQUAL operand .

    SEMI            reduce using rule 34 (var_assign -> ID PLUSEQUAL operand .)
    RPAREN          reduce using rule 34 (var_assign -> ID PLUSEQUAL operand .)


state 78

    (35) var_assign -> ID MINUSEQUAL operand .

    SEMI            reduce using rule 35 (var_assign -> ID MINUSEQUAL operand .)
    RPAREN          reduce using rule 35 (var_assign -> ID MINUSEQUAL operand .)


state 79

    (36) var_assign -> ID LSHIFTEQUAL operand .

    SEMI            reduce using rule 36 (var_assign -> ID LSHIFTEQUAL operand .)
    RPAREN          reduce using rule 36 (var_assign -> ID LSHIFTEQUAL operand .)


state 80

    (37) var_assign -> ID RSHIFTEQUAL operand .

    SEMI            reduce using rule 37 (var_assign -> ID RSHIFTEQUAL operand .)
    RPAREN          reduce using rule 37 (var_assign -> ID RSHIFTEQUAL operand .)


state 81

    (38) var_assign -> ID ANDEQUAL operand .

    SEMI            reduce using rule 38 (var_assign -> ID ANDEQUAL operand .)
    RPAREN          reduce using rule 38 (var_assign -> ID ANDEQUAL operand .)


state 82

    (39) var_assign -> ID OREQUAL operand .

    SEMI            reduce using rule 39 (var_assign -> ID OREQUAL operand .)
    RPAREN          reduce using rule 39 (var_assign -> ID OREQUAL operand .)


state 83

    (40) var_assign -> ID XOREQUAL operand .

    SEMI            reduce using rule 40 (var_assign -> ID XOREQUAL operand .)
    RPAREN          reduce using rule 40 (var_assign -> ID XOREQUAL operand .)


state 84

    (49) whileLoop -> WHILE LPAREN conditionals RPAREN . scope
    (45) scope -> . LBRACE statement_list RBRACE

    LBRACE          shift and go to state 15

    scope                          shift and go to state 96

state 85

    (50) conditionals -> operand compOps . operand
    (20) operand -> . ID
    (21) operand -> . NUMCONST

    ID              shift and go to state 60
    NUMCONST        shift and go to state 39

    operand                        shift and go to state 97

state 86

    (51) compOps -> LE .

    ID              reduce using rule 51 (compOps -> LE .)
    NUMCONST        reduce using rule 51 (compOps -> LE .)


state 87

    (52) compOps -> GE .

    ID              reduce using rule 52 (compOps -> GE .)
    NUMCONST        reduce using rule 52 (compOps -> GE .)


state 88

    (53) compOps -> EQ .

    ID              reduce using rule 53 (compOps -> EQ .)
    NUMCONST        reduce using rule 53 (compOps -> EQ .)


state 89

    (54) compOps -> NE .

    ID              reduce using rule 54 (compOps -> NE .)
    NUMCONST        reduce using rule 54 (compOps -> NE .)


state 90

    (9) expr -> expr PLUS multiplicative_expr .
    (12) multiplicative_expr -> multiplicative_expr . TIMES unary_expr
    (13) multiplicative_expr -> multiplicative_expr . DIVIDE unary_expr
    (14) multiplicative_expr -> multiplicative_expr . MODULO unary_expr

    PLUS            reduce using rule 9 (expr -> expr PLUS multiplicative_expr .)
    MINUS           reduce using rule 9 (expr -> expr PLUS multiplicative_expr .)
    SEMI            reduce using rule 9 (expr -> expr PLUS multiplicative_expr .)
    RPAREN          reduce using rule 9 (expr -> expr PLUS multiplicative_expr .)
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MODULO          shift and go to state 68


state 91

    (18) unary_expr -> operand . INCREMENT
    (19) unary_expr -> operand . DECREMENT

    INCREMENT       shift and go to state 62
    DECREMENT       shift and go to state 63


state 92

    (10) expr -> expr MINUS multiplicative_expr .
    (12) multiplicative_expr -> multiplicative_expr . TIMES unary_expr
    (13) multiplicative_expr -> multiplicative_expr . DIVIDE unary_expr
    (14) multiplicative_expr -> multiplicative_expr . MODULO unary_expr

    PLUS            reduce using rule 10 (expr -> expr MINUS multiplicative_expr .)
    MINUS           reduce using rule 10 (expr -> expr MINUS multiplicative_expr .)
    SEMI            reduce using rule 10 (expr -> expr MINUS multiplicative_expr .)
    RPAREN          reduce using rule 10 (expr -> expr MINUS multiplicative_expr .)
    TIMES           shift and go to state 66
    DIVIDE          shift and go to state 67
    MODULO          shift and go to state 68


state 93

    (12) multiplicative_expr -> multiplicative_expr TIMES unary_expr .

    TIMES           reduce using rule 12 (multiplicative_expr -> multiplicative_expr TIMES unary_expr .)
    DIVIDE          reduce using rule 12 (multiplicative_expr -> multiplicative_expr TIMES unary_expr .)
    MODULO          reduce using rule 12 (multiplicative_expr -> multiplicative_expr TIMES unary_expr .)
    PLUS            reduce using rule 12 (multiplicative_expr -> multiplicative_expr TIMES unary_expr .)
    MINUS           reduce using rule 12 (multiplicative_expr -> multiplicative_expr TIMES unary_expr .)
    SEMI            reduce using rule 12 (multiplicative_expr -> multiplicative_expr TIMES unary_expr .)
    RPAREN          reduce using rule 12 (multiplicative_expr -> multiplicative_expr TIMES unary_expr .)


state 94

    (13) multiplicative_expr -> multiplicative_expr DIVIDE unary_expr .

    TIMES           reduce using rule 13 (multiplicative_expr -> multiplicative_expr DIVIDE unary_expr .)
    DIVIDE          reduce using rule 13 (multiplicative_expr -> multiplicative_expr DIVIDE unary_expr .)
    MODULO          reduce using rule 13 (multiplicative_expr -> multiplicative_expr DIVIDE unary_expr .)
    PLUS            reduce using rule 13 (multiplicative_expr -> multiplicative_expr DIVIDE unary_expr .)
    MINUS           reduce using rule 13 (multiplicative_expr -> multiplicative_expr DIVIDE unary_expr .)
    SEMI            reduce using rule 13 (multiplicative_expr -> multiplicative_expr DIVIDE unary_expr .)
    RPAREN          reduce using rule 13 (multiplicative_expr -> multiplicative_expr DIVIDE unary_expr .)


state 95

    (14) multiplicative_expr -> multiplicative_expr MODULO unary_expr .

    TIMES           reduce using rule 14 (multiplicative_expr -> multiplicative_expr MODULO unary_expr .)
    DIVIDE          reduce using rule 14 (multiplicative_expr -> multiplicative_expr MODULO unary_expr .)
    MODULO          reduce using rule 14 (multiplicative_expr -> multiplicative_expr MODULO unary_expr .)
    PLUS            reduce using rule 14 (multiplicative_expr -> multiplicative_expr MODULO unary_expr .)
    MINUS           reduce using rule 14 (multiplicative_expr -> multiplicative_expr MODULO unary_expr .)
    SEMI            reduce using rule 14 (multiplicative_expr -> multiplicative_expr MODULO unary_expr .)
    RPAREN          reduce using rule 14 (multiplicative_expr -> multiplicative_expr MODULO unary_expr .)


state 96

    (49) whileLoop -> WHILE LPAREN conditionals RPAREN scope .

    WHILE           reduce using rule 49 (whileLoop -> WHILE LPAREN conditionals RPAREN scope .)
    RETURN          reduce using rule 49 (whileLoop -> WHILE LPAREN conditionals RPAREN scope .)
    ID              reduce using rule 49 (whileLoop -> WHILE LPAREN conditionals RPAREN scope .)
    LPAREN          reduce using rule 49 (whileLoop -> WHILE LPAREN conditionals RPAREN scope .)
    INT             reduce using rule 49 (whileLoop -> WHILE LPAREN conditionals RPAREN scope .)
    CHAR            reduce using rule 49 (whileLoop -> WHILE LPAREN conditionals RPAREN scope .)
    SEMI            reduce using rule 49 (whileLoop -> WHILE LPAREN conditionals RPAREN scope .)
    RBRACE          reduce using rule 49 (whileLoop -> WHILE LPAREN conditionals RPAREN scope .)


state 97

    (50) conditionals -> operand compOps operand .

    RPAREN          reduce using rule 50 (conditionals -> operand compOps operand .)

