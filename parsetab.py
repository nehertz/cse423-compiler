
# parsetab.py
# This file is automatically generated. Do not edit.
# pylint: disable=W,C,R
_tabversion = '3.10'

_lr_method = 'LALR'

_lr_signature = 'funcDeclAND ANDEQUAL ARROW AUTO BREAK CASE CHAR CHARACTER COLON COMMA CONST CONTINUE DECREMENT DEFAULT DIVEQUAL DIVIDE DO DOUBLE DQUOT ELLIPSIS ELSE ENUM EQ EQUALS EXTERN FALSE FLOAT FOR GE GOTO ID IF INCREMENT INT LAND LANGLE LBRACE LBRACKET LE LNOT LONG LOR LPAREN LSHIFT LSHIFTEQUAL MINUS MINUSEQUAL MODEQUAL MODULO NE NOT NUMCONST OR OREQUAL PERIOD PLUS PLUSEQUAL RANGLE RBRACE RBRACKET REGISTER RETURN RPAREN RSHIFT RSHIFTEQUAL SEMI SHORT SIGNED SIZEOF SQUOT STATIC STRING STRUCT SWITCH TIMES TIMESEQUAL TRUE TYPEDEF UNION UNSIGNED VOID VOLATILE WHILE XOR XOREQUALempty :\n    statement_list : empty\n                   | statement SEMI statement_list\n    statement : return_stmt\n              | var_decl\n              | var_assign\n              | whileLoop\n              | empty\n    \n    expr : operand bin_op operand\n    \n    operand : ID\n            | NUMCONST\n    \n    bin_op : PLUS\n           | MINUS\n           | TIMES\n           | DIVIDE\n           | MODULO\n    \n    return_stmt : RETURN operand\n                | RETURN expr\n                | RETURN var_assign\n    \n    var_decl : type_spec ID\n             | type_spec var_assign\n    \n    var_assign : ID EQUALS operand\n               | ID EQUALS expr\n               | ID EQUALS STRING\n               | LPAREN var_assign RPAREN\n    \n    type_spec_list : type_spec_list COMMA type_spec ID\n                   | type_spec ID\n    type_spec : INT\n              | CHAR\n    \n    scope : LBRACE statement_list RBRACE\n    \n    funcDecl : type_spec ID LPAREN args RPAREN scope\n    args : type_spec_list\n         | empty\n    \n    compOps     : LE\n                | GE\n                | EQ\n                | NE\n    \n    conditionals    : operand compOps operand\n                    | TRUE\n                    | FALSE\n    \n    whileLoop   : WHILE LPAREN conditionals RPAREN scope\n    '
    
_lr_action_items = {'INT':([0,6,13,15,31,],[3,3,3,3,3,]),'CHAR':([0,6,13,15,31,],[4,4,4,4,4,]),'$end':([1,14,30,],[0,-31,-30,]),'ID':([2,3,4,7,15,16,24,25,27,31,39,41,43,44,45,46,47,48,60,61,62,63,64,],[5,-28,-29,11,26,29,35,37,26,26,49,49,49,-12,-13,-14,-15,-16,49,-34,-35,-36,-37,]),'LPAREN':([3,4,5,15,24,25,27,28,31,],[-28,-29,6,27,27,27,27,41,27,]),'RPAREN':([6,8,9,10,11,29,36,40,49,50,51,52,53,54,56,57,58,66,],[-1,12,-32,-33,-27,-26,-11,53,-10,-22,-23,-24,-25,59,-39,-40,-9,-38,]),'COMMA':([9,11,29,],[13,-27,-26,]),'LBRACE':([12,59,],[15,15,]),'RBRACE':([15,17,18,31,42,],[-1,30,-2,-1,-3,]),'SEMI':([15,18,19,20,21,22,23,30,31,32,33,34,35,36,37,38,49,50,51,52,53,58,65,],[-1,-8,31,-4,-5,-6,-7,-30,-1,-17,-18,-19,-10,-11,-20,-21,-10,-22,-23,-24,-25,-9,-41,]),'RETURN':([15,31,],[24,24,]),'WHILE':([15,31,],[28,28,]),'NUMCONST':([24,39,41,43,44,45,46,47,48,60,61,62,63,64,],[36,36,36,36,-12,-13,-14,-15,-16,36,-34,-35,-36,-37,]),'EQUALS':([26,35,37,],[39,39,39,]),'PLUS':([32,35,36,49,50,],[44,-10,-11,-10,44,]),'MINUS':([32,35,36,49,50,],[45,-10,-11,-10,45,]),'TIMES':([32,35,36,49,50,],[46,-10,-11,-10,46,]),'DIVIDE':([32,35,36,49,50,],[47,-10,-11,-10,47,]),'MODULO':([32,35,36,49,50,],[48,-10,-11,-10,48,]),'LE':([36,49,55,],[-11,-10,61,]),'GE':([36,49,55,],[-11,-10,62,]),'EQ':([36,49,55,],[-11,-10,63,]),'NE':([36,49,55,],[-11,-10,64,]),'STRING':([39,],[52,]),'TRUE':([41,],[56,]),'FALSE':([41,],[57,]),}

_lr_action = {}
for _k, _v in _lr_action_items.items():
   for _x,_y in zip(_v[0],_v[1]):
      if not _x in _lr_action:  _lr_action[_x] = {}
      _lr_action[_x][_k] = _y
del _lr_action_items

_lr_goto_items = {'funcDecl':([0,],[1,]),'type_spec':([0,6,13,15,31,],[2,7,16,25,25,]),'args':([6,],[8,]),'type_spec_list':([6,],[9,]),'empty':([6,15,31,],[10,18,18,]),'scope':([12,59,],[14,65,]),'statement_list':([15,31,],[17,42,]),'statement':([15,31,],[19,19,]),'return_stmt':([15,31,],[20,20,]),'var_decl':([15,31,],[21,21,]),'var_assign':([15,24,25,27,31,],[22,34,38,40,22,]),'whileLoop':([15,31,],[23,23,]),'operand':([24,39,41,43,60,],[32,50,55,58,66,]),'expr':([24,39,],[33,51,]),'bin_op':([32,50,],[43,43,]),'conditionals':([41,],[54,]),'compOps':([55,],[60,]),}

_lr_goto = {}
for _k, _v in _lr_goto_items.items():
   for _x, _y in zip(_v[0], _v[1]):
       if not _x in _lr_goto: _lr_goto[_x] = {}
       _lr_goto[_x][_k] = _y
del _lr_goto_items
_lr_productions = [
  ("S' -> funcDecl","S'",1,None,None,None),
  ('empty -> <empty>','empty',0,'p_empty','ply_parser.py',23),
  ('statement_list -> empty','statement_list',1,'p_statement_list','ply_parser.py',28),
  ('statement_list -> statement SEMI statement_list','statement_list',3,'p_statement_list','ply_parser.py',29),
  ('statement -> return_stmt','statement',1,'p_statement_list','ply_parser.py',30),
  ('statement -> var_decl','statement',1,'p_statement_list','ply_parser.py',31),
  ('statement -> var_assign','statement',1,'p_statement_list','ply_parser.py',32),
  ('statement -> whileLoop','statement',1,'p_statement_list','ply_parser.py',33),
  ('statement -> empty','statement',1,'p_statement_list','ply_parser.py',34),
  ('expr -> operand bin_op operand','expr',3,'p_expr','ply_parser.py',39),
  ('operand -> ID','operand',1,'p_operand','ply_parser.py',43),
  ('operand -> NUMCONST','operand',1,'p_operand','ply_parser.py',44),
  ('bin_op -> PLUS','bin_op',1,'p_bin_op','ply_parser.py',48),
  ('bin_op -> MINUS','bin_op',1,'p_bin_op','ply_parser.py',49),
  ('bin_op -> TIMES','bin_op',1,'p_bin_op','ply_parser.py',50),
  ('bin_op -> DIVIDE','bin_op',1,'p_bin_op','ply_parser.py',51),
  ('bin_op -> MODULO','bin_op',1,'p_bin_op','ply_parser.py',52),
  ('return_stmt -> RETURN operand','return_stmt',2,'p_return_stmt','ply_parser.py',58),
  ('return_stmt -> RETURN expr','return_stmt',2,'p_return_stmt','ply_parser.py',59),
  ('return_stmt -> RETURN var_assign','return_stmt',2,'p_return_stmt','ply_parser.py',60),
  ('var_decl -> type_spec ID','var_decl',2,'p_var_decl','ply_parser.py',65),
  ('var_decl -> type_spec var_assign','var_decl',2,'p_var_decl','ply_parser.py',66),
  ('var_assign -> ID EQUALS operand','var_assign',3,'p_var_assign','ply_parser.py',73),
  ('var_assign -> ID EQUALS expr','var_assign',3,'p_var_assign','ply_parser.py',74),
  ('var_assign -> ID EQUALS STRING','var_assign',3,'p_var_assign','ply_parser.py',75),
  ('var_assign -> LPAREN var_assign RPAREN','var_assign',3,'p_var_assign','ply_parser.py',76),
  ('type_spec_list -> type_spec_list COMMA type_spec ID','type_spec_list',4,'p_typeSpec','ply_parser.py',81),
  ('type_spec_list -> type_spec ID','type_spec_list',2,'p_typeSpec','ply_parser.py',82),
  ('type_spec -> INT','type_spec',1,'p_typeSpec','ply_parser.py',83),
  ('type_spec -> CHAR','type_spec',1,'p_typeSpec','ply_parser.py',84),
  ('scope -> LBRACE statement_list RBRACE','scope',3,'p_scope','ply_parser.py',113),
  ('funcDecl -> type_spec ID LPAREN args RPAREN scope','funcDecl',6,'p_funcDeclaration','ply_parser.py',118),
  ('args -> type_spec_list','args',1,'p_funcDeclaration','ply_parser.py',119),
  ('args -> empty','args',1,'p_funcDeclaration','ply_parser.py',120),
  ('compOps -> LE','compOps',1,'p_compOps','ply_parser.py',124),
  ('compOps -> GE','compOps',1,'p_compOps','ply_parser.py',125),
  ('compOps -> EQ','compOps',1,'p_compOps','ply_parser.py',126),
  ('compOps -> NE','compOps',1,'p_compOps','ply_parser.py',127),
  ('conditionals -> operand compOps operand','conditionals',3,'p_conditionals','ply_parser.py',131),
  ('conditionals -> TRUE','conditionals',1,'p_conditionals','ply_parser.py',132),
  ('conditionals -> FALSE','conditionals',1,'p_conditionals','ply_parser.py',133),
  ('whileLoop -> WHILE LPAREN conditionals RPAREN scope','whileLoop',5,'p_whileLoop','ply_parser.py',137),
]
